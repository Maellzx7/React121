{"version":3,"names":["_assert","require","_core","_helperModuleImports","_rewriteThis","_rewriteLiveReferences","_normalizeAndLoadMetadata","Lazy","_dynamicImport","_getModuleName","exports","getDynamicImportSource","rewriteModuleStatementsAndPrepareHeader","path","exportName","strict","allowTopLevelThis","strictMode","noInterop","importInterop","lazy","getWrapperPayload","toGetWrapperPayload","wrapReference","esNamespaceOnly","filename","constantReexports","arguments","loose","enumerableModuleMeta","noIncompleteNsImportDetection","validateImportInteropOption","assert","isModule","node","sourceType","meta","normalizeModuleAndLoadMetadata","initializeReexports","rewriteThis","rewriteLiveReferences","hasStrict","directives","some","directive","value","unshiftContainer","t","directiveLiteral","headers","hasExports","push","buildESModuleHeader","nameList","buildExportNameListDeclaration","exportNameListName","name","statement","buildExportInitializationStatements","ensureStatementsHoisted","statements","forEach","header","_blockHoist","wrapInterop","programPath","expr","type","callExpression","hub","addHelper","booleanLiteral","helper","Error","buildNamespaceInitStatements","metadata","sourceMetadata","_wrapReference","srcNamespaceId","identifier","localName","importsNamespace","template","NAME","SOURCE","cloneNode","srcNamespace","wrap","buildReexportsFromMeta","reexportNamespace","isIdentifier","EXPORTS","NAMESPACE","reexportAll","buildNamespaceReexport","loc","ReexportTemplate","constant","namespaceImport","ast","constantComputed","spec","_wrapReference2","namespace","stringSpecifiers","Array","from","reexports","importName","interop","has","memberExpression","stringLiteral","astNodes","VERIFY_NAME_LIST","EXPORTS_LIST","exportedVars","Object","create","data","local","values","names","hasReexport","source","keys","length","scope","generateUidIdentifier","default","variableDeclaration","variableDeclarator","valueToNode","initStatements","kind","buildInitStatement","reexportsStatements","i","sort","a","b","results","initStatement","chunkSize","uninitializedExportNames","j","buildUndefinedNode","InitTemplate","computed","expression","define","exportNames","initExpr","expressionStatement","reduce","params"],"sources":["../src/index.ts"],"sourcesContent":["import assert from \"assert\";\nimport { template, types as t } from \"@babel/core\";\n\nimport { isModule } from \"@babel/helper-module-imports\";\n\nimport rewriteThis from \"./rewrite-this.ts\";\nimport rewriteLiveReferences from \"./rewrite-live-references.ts\";\nimport normalizeModuleAndLoadMetadata, {\n  hasExports,\n  isSideEffectImport,\n  validateImportInteropOption,\n} from \"./normalize-and-load-metadata.ts\";\nimport type {\n  ImportInterop,\n  InteropType,\n  ModuleMetadata,\n  SourceModuleMetadata,\n} from \"./normalize-and-load-metadata.ts\";\nimport * as Lazy from \"./lazy-modules.ts\";\nimport type { NodePath } from \"@babel/core\";\n\nexport { buildDynamicImport } from \"./dynamic-import.ts\";\n\nif (!process.env.BABEL_8_BREAKING && !USE_ESM && !IS_STANDALONE) {\n  // eslint-disable-next-line no-restricted-globals\n  exports.getDynamicImportSource =\n    // eslint-disable-next-line no-restricted-globals, import/extensions\n    require(\"./dynamic-import\").getDynamicImportSource;\n}\n\nexport { default as getModuleName } from \"./get-module-name.ts\";\nexport type { PluginOptions } from \"./get-module-name.ts\";\n\nexport { hasExports, isSideEffectImport, isModule, rewriteThis };\n\nexport interface RewriteModuleStatementsAndPrepareHeaderOptions {\n  exportName?: string;\n  strict: boolean;\n  allowTopLevelThis?: boolean;\n  strictMode: boolean;\n  loose?: boolean;\n  importInterop?: ImportInterop;\n  noInterop?: boolean;\n  lazy?: Lazy.Lazy;\n  getWrapperPayload?: (\n    source: string,\n    metadata: SourceModuleMetadata,\n    importNodes: t.Node[],\n  ) => unknown;\n  wrapReference?: (ref: t.Expression, payload: unknown) => t.Expression | null;\n  esNamespaceOnly?: boolean;\n  filename: string | undefined;\n  constantReexports?: boolean | void;\n  enumerableModuleMeta?: boolean | void;\n  noIncompleteNsImportDetection?: boolean | void;\n}\n\n/**\n * Perform all of the generic ES6 module rewriting needed to handle initial\n * module processing. This function will rewrite the majority of the given\n * program to reference the modules described by the returned metadata,\n * and returns a list of statements for use when initializing the module.\n */\nexport function rewriteModuleStatementsAndPrepareHeader(\n  path: NodePath<t.Program>,\n  {\n    exportName,\n    strict,\n    allowTopLevelThis,\n    strictMode,\n    noInterop,\n    importInterop = noInterop ? \"none\" : \"babel\",\n    // TODO(Babel 8): After that `lazy` implementation is moved to the CJS\n    // transform, remove this parameter.\n    lazy,\n    getWrapperPayload = Lazy.toGetWrapperPayload(lazy ?? false),\n    wrapReference = Lazy.wrapReference,\n    esNamespaceOnly,\n    filename,\n\n    constantReexports = process.env.BABEL_8_BREAKING\n      ? undefined\n      : arguments[1].loose,\n    enumerableModuleMeta = process.env.BABEL_8_BREAKING\n      ? undefined\n      : arguments[1].loose,\n    noIncompleteNsImportDetection,\n  }: RewriteModuleStatementsAndPrepareHeaderOptions,\n) {\n  validateImportInteropOption(importInterop);\n  assert(isModule(path), \"Cannot process module statements in a script\");\n  path.node.sourceType = \"script\";\n\n  const meta = normalizeModuleAndLoadMetadata(path, exportName, {\n    importInterop,\n    initializeReexports: constantReexports,\n    getWrapperPayload,\n    esNamespaceOnly,\n    filename,\n  });\n\n  if (!allowTopLevelThis) {\n    rewriteThis(path);\n  }\n\n  rewriteLiveReferences(path, meta, wrapReference);\n\n  if (strictMode !== false) {\n    const hasStrict = path.node.directives.some(directive => {\n      return directive.value.value === \"use strict\";\n    });\n    if (!hasStrict) {\n      path.unshiftContainer(\n        \"directives\",\n        t.directive(t.directiveLiteral(\"use strict\")),\n      );\n    }\n  }\n\n  const headers = [];\n  if (hasExports(meta) && !strict) {\n    headers.push(buildESModuleHeader(meta, enumerableModuleMeta));\n  }\n\n  const nameList = buildExportNameListDeclaration(path, meta);\n\n  if (nameList) {\n    meta.exportNameListName = nameList.name;\n    headers.push(nameList.statement);\n  }\n\n  // Create all of the statically known named exports.\n  headers.push(\n    ...buildExportInitializationStatements(\n      path,\n      meta,\n      wrapReference,\n      constantReexports,\n      noIncompleteNsImportDetection,\n    ),\n  );\n\n  return { meta, headers };\n}\n\n/**\n * Flag a set of statements as hoisted above all else so that module init\n * statements all run before user code.\n */\nexport function ensureStatementsHoisted(statements: t.Statement[]) {\n  // Force all of the header fields to be at the top of the file.\n  statements.forEach(header => {\n    // @ts-expect-error Fixme: handle _blockHoist property\n    header._blockHoist = 3;\n  });\n}\n\n/**\n * Given an expression for a standard import object, like \"require('foo')\",\n * wrap it in a call to the interop helpers based on the type.\n */\nexport function wrapInterop(\n  programPath: NodePath<t.Program>,\n  expr: t.Expression,\n  type: InteropType,\n): t.CallExpression {\n  if (type === \"none\") {\n    return null;\n  }\n\n  if (type === \"node-namespace\") {\n    return t.callExpression(\n      programPath.hub.addHelper(\"interopRequireWildcard\"),\n      [expr, t.booleanLiteral(true)],\n    );\n  } else if (type === \"node-default\") {\n    return null;\n  }\n\n  let helper;\n  if (type === \"default\") {\n    helper = \"interopRequireDefault\";\n  } else if (type === \"namespace\") {\n    helper = \"interopRequireWildcard\";\n  } else {\n    throw new Error(`Unknown interop: ${type}`);\n  }\n\n  return t.callExpression(programPath.hub.addHelper(helper), [expr]);\n}\n\n/**\n * Create the runtime initialization statements for a given requested source.\n * These will initialize all of the runtime import/export logic that\n * can't be handled statically by the statements created by\n * buildExportInitializationStatements().\n */\nexport function buildNamespaceInitStatements(\n  metadata: ModuleMetadata,\n  sourceMetadata: SourceModuleMetadata,\n  constantReexports: boolean | void = false,\n  wrapReference: (\n    ref: t.Identifier,\n    payload: unknown,\n  ) => t.Expression | null = Lazy.wrapReference,\n) {\n  const statements = [];\n\n  const srcNamespaceId = t.identifier(sourceMetadata.name);\n\n  for (const localName of sourceMetadata.importsNamespace) {\n    if (localName === sourceMetadata.name) continue;\n\n    // Create and assign binding to namespace object\n    statements.push(\n      template.statement`var NAME = SOURCE;`({\n        NAME: localName,\n        SOURCE: t.cloneNode(srcNamespaceId),\n      }),\n    );\n  }\n\n  const srcNamespace =\n    wrapReference(srcNamespaceId, sourceMetadata.wrap) ?? srcNamespaceId;\n\n  if (constantReexports) {\n    statements.push(\n      ...buildReexportsFromMeta(metadata, sourceMetadata, true, wrapReference),\n    );\n  }\n  for (const exportName of sourceMetadata.reexportNamespace) {\n    // Assign export to namespace object.\n    statements.push(\n      (!t.isIdentifier(srcNamespace)\n        ? template.statement`\n            Object.defineProperty(EXPORTS, \"NAME\", {\n              enumerable: true,\n              get: function() {\n                return NAMESPACE;\n              }\n            });\n          `\n        : template.statement`EXPORTS.NAME = NAMESPACE;`)({\n        EXPORTS: metadata.exportName,\n        NAME: exportName,\n        NAMESPACE: t.cloneNode(srcNamespace),\n      }),\n    );\n  }\n  if (sourceMetadata.reexportAll) {\n    const statement = buildNamespaceReexport(\n      metadata,\n      t.cloneNode(srcNamespace),\n      constantReexports,\n    );\n    statement.loc = sourceMetadata.reexportAll.loc;\n\n    // Iterate props creating getter for each prop.\n    statements.push(statement);\n  }\n  return statements;\n}\n\ninterface ReexportParts {\n  exports: string;\n  exportName: string;\n  namespaceImport: t.Expression;\n}\n\nconst ReexportTemplate = {\n  constant: ({ exports, exportName, namespaceImport }: ReexportParts) =>\n    template.statement.ast`\n      ${exports}.${exportName} = ${namespaceImport};\n    `,\n  constantComputed: ({ exports, exportName, namespaceImport }: ReexportParts) =>\n    template.statement.ast`\n      ${exports}[\"${exportName}\"] = ${namespaceImport};\n    `,\n  spec: ({ exports, exportName, namespaceImport }: ReexportParts) =>\n    template.statement.ast`\n      Object.defineProperty(${exports}, \"${exportName}\", {\n        enumerable: true,\n        get: function() {\n          return ${namespaceImport};\n        },\n      });\n    `,\n};\n\nfunction buildReexportsFromMeta(\n  meta: ModuleMetadata,\n  metadata: SourceModuleMetadata,\n  constantReexports: boolean,\n  wrapReference: (ref: t.Expression, payload: unknown) => t.Expression | null,\n): t.Statement[] {\n  let namespace: t.Expression = t.identifier(metadata.name);\n  namespace = wrapReference(namespace, metadata.wrap) ?? namespace;\n\n  const { stringSpecifiers } = meta;\n  return Array.from(metadata.reexports, ([exportName, importName]) => {\n    let namespaceImport: t.Expression = t.cloneNode(namespace);\n    if (importName === \"default\" && metadata.interop === \"node-default\") {\n      // Nothing, it's ok as-is\n    } else if (stringSpecifiers.has(importName)) {\n      namespaceImport = t.memberExpression(\n        namespaceImport,\n        t.stringLiteral(importName),\n        true,\n      );\n    } else {\n      namespaceImport = t.memberExpression(\n        namespaceImport,\n        t.identifier(importName),\n      );\n    }\n    const astNodes: ReexportParts = {\n      exports: meta.exportName,\n      exportName,\n      namespaceImport,\n    };\n    if (constantReexports || t.isIdentifier(namespaceImport)) {\n      if (stringSpecifiers.has(exportName)) {\n        return ReexportTemplate.constantComputed(astNodes);\n      } else {\n        return ReexportTemplate.constant(astNodes);\n      }\n    } else {\n      return ReexportTemplate.spec(astNodes);\n    }\n  });\n}\n\n/**\n * Build an \"__esModule\" header statement setting the property on a given object.\n */\nfunction buildESModuleHeader(\n  metadata: ModuleMetadata,\n  enumerableModuleMeta: boolean | void = false,\n) {\n  return (\n    enumerableModuleMeta\n      ? template.statement`\n        EXPORTS.__esModule = true;\n      `\n      : template.statement`\n        Object.defineProperty(EXPORTS, \"__esModule\", {\n          value: true,\n        });\n      `\n  )({ EXPORTS: metadata.exportName });\n}\n\n/**\n * Create a re-export initialization loop for a specific imported namespace.\n */\nfunction buildNamespaceReexport(\n  metadata: ModuleMetadata,\n  namespace: t.Expression,\n  constantReexports: boolean | void,\n) {\n  return (\n    constantReexports\n      ? template.statement`\n        Object.keys(NAMESPACE).forEach(function(key) {\n          if (key === \"default\" || key === \"__esModule\") return;\n          VERIFY_NAME_LIST;\n          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;\n\n          EXPORTS[key] = NAMESPACE[key];\n        });\n      `\n      : // Also skip already assigned bindings if they are strictly equal\n        // to be somewhat more spec-compliant when a file has multiple\n        // namespace re-exports that would cause a binding to be exported\n        // multiple times. However, multiple bindings of the same name that\n        // export the same primitive value are silently skipped\n        // (the spec requires an \"ambiguous bindings\" early error here).\n        template.statement`\n        Object.keys(NAMESPACE).forEach(function(key) {\n          if (key === \"default\" || key === \"__esModule\") return;\n          VERIFY_NAME_LIST;\n          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;\n\n          Object.defineProperty(EXPORTS, key, {\n            enumerable: true,\n            get: function() {\n              return NAMESPACE[key];\n            },\n          });\n        });\n    `\n  )({\n    NAMESPACE: namespace,\n    EXPORTS: metadata.exportName,\n    VERIFY_NAME_LIST: metadata.exportNameListName\n      ? template`\n            if (Object.prototype.hasOwnProperty.call(EXPORTS_LIST, key)) return;\n          `({ EXPORTS_LIST: metadata.exportNameListName })\n      : null,\n  });\n}\n\n/**\n * Build a statement declaring a variable that contains all of the exported\n * variable names in an object so they can easily be referenced from an\n * export * from statement to check for conflicts.\n */\nfunction buildExportNameListDeclaration(\n  programPath: NodePath,\n  metadata: ModuleMetadata,\n) {\n  const exportedVars = Object.create(null);\n  for (const data of metadata.local.values()) {\n    for (const name of data.names) {\n      exportedVars[name] = true;\n    }\n  }\n\n  let hasReexport = false;\n  for (const data of metadata.source.values()) {\n    for (const exportName of data.reexports.keys()) {\n      exportedVars[exportName] = true;\n    }\n    for (const exportName of data.reexportNamespace) {\n      exportedVars[exportName] = true;\n    }\n\n    hasReexport = hasReexport || !!data.reexportAll;\n  }\n\n  if (!hasReexport || Object.keys(exportedVars).length === 0) return null;\n\n  const name = programPath.scope.generateUidIdentifier(\"exportNames\");\n\n  delete exportedVars.default;\n\n  return {\n    name: name.name,\n    statement: t.variableDeclaration(\"var\", [\n      t.variableDeclarator(name, t.valueToNode(exportedVars)),\n    ]),\n  };\n}\n\n/**\n * Create a set of statements that will initialize all of the statically-known\n * export names with their expected values.\n */\nfunction buildExportInitializationStatements(\n  programPath: NodePath,\n  metadata: ModuleMetadata,\n  wrapReference: (ref: t.Expression, payload: unknown) => t.Expression | null,\n  constantReexports: boolean | void = false,\n  noIncompleteNsImportDetection: boolean | void = false,\n) {\n  const initStatements: Array<[string, t.Statement | null]> = [];\n\n  for (const [localName, data] of metadata.local) {\n    if (data.kind === \"import\") {\n      // No-open since these are explicitly set with the \"reexports\" block.\n    } else if (data.kind === \"hoisted\") {\n      initStatements.push([\n        // data.names is always of length 1 because a hoisted export\n        // name must be id of a function declaration\n        data.names[0],\n        buildInitStatement(metadata, data.names, t.identifier(localName)),\n      ]);\n    } else if (!noIncompleteNsImportDetection) {\n      for (const exportName of data.names) {\n        initStatements.push([exportName, null]);\n      }\n    }\n  }\n\n  for (const data of metadata.source.values()) {\n    if (!constantReexports) {\n      const reexportsStatements = buildReexportsFromMeta(\n        metadata,\n        data,\n        false,\n        wrapReference,\n      );\n      const reexports = [...data.reexports.keys()];\n      for (let i = 0; i < reexportsStatements.length; i++) {\n        initStatements.push([reexports[i], reexportsStatements[i]]);\n      }\n    }\n    if (!noIncompleteNsImportDetection) {\n      for (const exportName of data.reexportNamespace) {\n        initStatements.push([exportName, null]);\n      }\n    }\n  }\n\n  // https://tc39.es/ecma262/#sec-module-namespace-exotic-objects\n  // The [Exports] list is ordered as if an Array of those String values\n  // had been sorted using %Array.prototype.sort% using undefined as comparefn\n  initStatements.sort(([a], [b]) => {\n    if (a < b) return -1;\n    if (b < a) return 1;\n    return 0;\n  });\n\n  const results = [];\n  if (noIncompleteNsImportDetection) {\n    for (const [, initStatement] of initStatements) {\n      results.push(initStatement);\n    }\n  } else {\n    // We generate init statements (`exports.a = exports.b = ... = void 0`)\n    // for every 100 exported names to avoid deeply-nested AST structures.\n    const chunkSize = 100;\n    for (let i = 0; i < initStatements.length; i += chunkSize) {\n      let uninitializedExportNames = [];\n      for (let j = 0; j < chunkSize && i + j < initStatements.length; j++) {\n        const [exportName, initStatement] = initStatements[i + j];\n        if (initStatement !== null) {\n          if (uninitializedExportNames.length > 0) {\n            results.push(\n              buildInitStatement(\n                metadata,\n                uninitializedExportNames,\n                programPath.scope.buildUndefinedNode(),\n              ),\n            );\n            // reset after uninitializedExportNames has been transformed\n            // to init statements\n            uninitializedExportNames = [];\n          }\n          results.push(initStatement);\n        } else {\n          uninitializedExportNames.push(exportName);\n        }\n      }\n      if (uninitializedExportNames.length > 0) {\n        results.push(\n          buildInitStatement(\n            metadata,\n            uninitializedExportNames,\n            programPath.scope.buildUndefinedNode(),\n          ),\n        );\n      }\n    }\n  }\n\n  return results;\n}\n\ninterface InitParts {\n  exports: string;\n  name: string;\n  value: t.Expression;\n}\n\n/**\n * Given a set of export names, create a set of nested assignments to\n * initialize them all to a given expression.\n */\nconst InitTemplate = {\n  computed: ({ exports, name, value }: InitParts) =>\n    template.expression.ast`${exports}[\"${name}\"] = ${value}`,\n  default: ({ exports, name, value }: InitParts) =>\n    template.expression.ast`${exports}.${name} = ${value}`,\n  define: ({ exports, name, value }: InitParts) =>\n    template.expression.ast`\n      Object.defineProperty(${exports}, \"${name}\", {\n        enumerable: true,\n        value: void 0,\n        writable: true\n      })[\"${name}\"] = ${value}`,\n};\n\nfunction buildInitStatement(\n  metadata: ModuleMetadata,\n  exportNames: string[],\n  initExpr: t.Expression,\n) {\n  const { stringSpecifiers, exportName: exports } = metadata;\n  return t.expressionStatement(\n    exportNames.reduce((value, name) => {\n      const params = {\n        exports,\n        name,\n  }4MĞø7hü§¼ñïzãó$ìñ¯Á¿ğx6ôfI€ò‘19şÓDúGş—úçÎ¬!Âÿ±ş©a“Ğÿí¸ÚÂõë¿lôûƒÉ¨?èöûıaZ{8GZ·o˜[¾Ÿï’C„Œ¤
ş%C(íE–£ şånr ¶-s·ĞÏ
½B±Ûí–è'°ãĞßh4$ R&§‰=“Öø>Ù”~¯×ë'	şOÃ¦ŸÍºıiÖ²qA³l•À-’ê>óÜß|Ué~ÁeÀ±pØ­P`õãÓ€8ÂF„Wk 4\&©óëÅ˜Ã®>·!ó–kÛ†åE+Rş'{§ÃÄA`ü ØËÜ~€™€è D˜Hà/O@ëR˜NÙ­8€9@-fÓ`~{ÿgå2"@n|ÀÿÁR‹Å*4'PÀI?~le…A~0è'ú}u¸I`JğßCh2Øæ‚¶oÿ®¸;˜÷ØèÀ-H 9ÿÓ£tZ· hîOq‚]¬Èl6ÖÈçIÍ3ÈæU¼hß=1ÚÑşË¾s„	$=M§‹ì¹Cö|B~ßÜ[ÿ¢óù,N×!9óã.ãÂşËãp%i€Ú0M¼Ñ/ê-Ç}vÅ|Ølw3><`f1vl²ˆfÑ	ÇÎé<®µÅ±ázÀ·A€u>‘Üğ–uda@¤à=êZ—örÁ{>ycÀ‹¿F&Iÿ-O™0îó2¶5æs2(ıSrL¯ËT×µ™€Ç½ôı~:#¿ºKv{U^Ï! ƒ™ä¡€®Ş’,;Î°ÎÛ§$‹ú)¦¼/.«hò¹;"òšı‹ııóE#åT•ñÿò’ãßõÿÈ^”»
ş!Õó	 ®ÿäXù<w†&¤[… ˜$'“Qj4’ûß/’ştZ’¤Xÿ0†Ùñq»oY/˜ßµûıî ?`³şL€~Ù«€õĞ?µ ¬ GH‚şßL¥dÁ± õ?,^TdIg2³L6;ÈæƒDş¸œE¨?rş±ãĞ/I€kö@m|ív{Ğëµy@&Ë†Cğû	€¬Ç¼ÿÑ­~ûÛ¦¨‚îã<xy&<aìJ'Xšşêí‚ ˜ºS|åÜl­' ¤ü{y	0Ùİ æo:=àÀİb	Ä?¶‹$ø—‘WğøÒB‚ÜÇÄcc„ÀmŒÿAmĞ²ú?g\Åe)´¢H&Ì¨—5£@ËÂ0—Ëõô?jÙ²p†å:1ˆÂj/èò±³	¬¸ŞqlóAÎÈæµişÓˆ5††w– vBA ˜IÓì¥ğVÓiş-n3?Ú×Îİ§gü«}çÈ¬PÈwóùL?“Aÿ“Ùt ³%0ÓuĞÇc;cÛÃÜp8(İÓ–ir­Ä&@ ;şã^»üĞÙ±Â^«‚ çws+u<!À_' Ïl°ò|v |øDjM ØOØQ™V¢™brk€_™-ïÖıó4‰«®¶ŸOŠä‹Åˆ‰LHf$óÈÇ¾ÆÒÉtz?½¿oæh1°z=£B‹EIì¨!Ò·Såõàùà%©-*¼İ÷‘^ÄˆEFzæ‚`Ç@5=CÇsüe¸¿êF;G2"@¶ Š,y¯HŒ-+!¯ûØ'ùÿêİ±…×;ş]véÅ%úùFÃ|îÎ1î :,Î½úŸ‘{ıOçÓ) šÖZ6™Íd°›Õµ»]½¢ëZ~	şe„T0Ã_²ãÁ€¹wø«-Ï6î°Êh5y" ˜p8Q*øGQ ÏÖBïï‡¥¼šN[i´u‡ù£h+ˆ  gœØâø€Å%$DØïvy[úı¿’ÚŸ½P?.“ €N/Æ¹¸/Sd€ƒ”D>ŒÚâ˜£ŒëÖÛmSÔE0	ø™#61'lfoÛ†^»íô€‹T·ı9¶Ü—íŸğS°ÍFƒ5p*€şØñ—‘øËñ&Çßm Ïkô.B@0gà÷x§"!êçad1¿ÌrÓ-UN¥üëÄ­ [L;;ˆÛ\g*;ş1·1×Õù¿?&Ÿ§N6¯Y,æ:¹Üx@ —d<½O#FÜ0
ÉB!“&Àû·ÈçùQLM¤½Éí”h /ì~P	§R)5J¥B›@[/›b1Ş’ÉLŒÍ(I2‘LŒBÁ¥õàş_jOu)Á¿ôÿn»âû:‰Å³åy~Õ˜rßk±3Tö|ë­åíŸ¨‹B¼W  ó²F6B¤O„ˆµ®„\ëĞ0Vncƒ\S×s1X½V“‹&EòU2Ùè7r  ñ#Hhm×³$’‡£‡³D‚ïEz€,!¼ÓP<'w-"\6Ïsˆ|g„U«§¡Á¯ó÷Jş—z7vÃ&Ù¶ÿ"‹şa	Ì8RÄ“"E`G Ò3¿ òLcĞ¢ºq„W7öƒÂŸŞ‘ÅàÆÇ¿{†3zÛòa«ú7è_uå³¤ı«E®0î ı~ôáaäe$r48:‚ş%$	 ZÂè×ÿœô3±³ü«ú
ğU9kwÈ–»ık,;3ÄZ99¾e5{şôËv<(×Aş(üHa#•²SFÓn¦-h1•mşİ~Şd°¦-ïõ|€Ÿø&Î"½˜\$=@
@>v ı  ÷ñ<HœŒ£ö È@ïø£ß¨ëÆÃH‘ú?˜ZMÑæóíÉÁ[HøÜx<º­†
Ç¾mŠóW†‹¯+7áşÁOğ¬ø!vúQ ÷1Šdá?ôcÌÉñw;£r1ÿç²$ È3¤»
?xˆ9•¢u¦›aŒCO¬®7v	@Oı<[{~/„ÿ(İÕÍtlåDaÜ£ëQí¯¥öí;€ä‘e‹ù?Ûß?¬îïíÅñx³Õl’
{4Mø>’  77ÛG.næpxx­F£ØäàÅ$ÿ%y “ƒŞßĞ4Ù÷	àìŸ$ÑH$:$8*—†­EËÿ¶_€çX,ABî}
µ.KV©”g2ú\×c‡ ½–à_V}šıPå¤qÖ£ù“›'úf§ô¨ıËÿšöëI#Uº­j§É¤¯Ïî9ìñzŸHúCh_r#D]ïàİxjäÔ# \ßzè X’M,+ç_øš¤K‚E@NÕ&¬›‡sŒç÷£ûûóø|>1&G•ÑeqŒ  µ¥„ñû¼ÍÆï,ğ/	 ˜Y@©TZ`ÃaáHÂÊ*Ò¶ÌyŸ»Úgü«àOk, ×£#sÜ¸÷ÀŒÿí×šÇëÀ¿ –J Àı‡şWÎ;ß- –aó¬ÁöŒññxÜ$şá¨œ 8 Ğ¿Cç	úç¹:ş¸0üRÿÖæ&Qÿ‹Q›^ÿQÕÈ©gçŠ#¢ä1'¢Å½
¨Aé6~,°¼M&GÉ¤6ÒêBİë3ˆ sóÜo üjs}WM´.ÛğyÔ¾áÒDæyéb^ÓÚEj	€çºŠB– ä‰²`QìŸ“ü"‘Ğ_èºaFšº“¦kôQÔ>Z†Ú'^vî²›I¨VŸ}=û/üDÿ?w?èÔ±1ç6¼ÓÛg&â=êˆ9!°6¢€oj°¼ù: ÿãbşÏI€%Ï@–WCn|PÃüJâd šnÉ19À‰Õ5âöV—wD-­!‰š%àFA°; 2eK†(cÀ(û­ı}­¡iÇ$’6R™Hàû€  Á-mÀ/vÌ+ÕJeBPŠÜ€å˜¨ı1	4€İÿ•¾©ïuA€¸Ç®{T?:j‘Àö“Ë>Dÿ§^Ä. ½I ØüÁkœ<‰b™=šÍF‘ÕÓ]eéŒ&Å×©ËNö?êQÖ»&´Ò¥™¨¥_Ü?‹$±È'°Ç~Í¿"Û ?O†Ï]ã8`t§«ÓJšMİnªğsB'X.˜ÒÆy¯ FxÖò’Q*!/Æ<Ç ,áƒ	Òñ¶İw–.Ú3‰¦¨ta‘¿^õNƒW% àã‚àèP.—T¶h!R›I"`àA¤ Ö 8üKğ§ İéü!¬:·s;örsàÇÿy£å*.ïßYêø÷  {0äWĞ—Æ€môˆê&Ç`¾G-ÕjiÍ7$Ğ?©I @×p @à9HRN•Ë\ÿ¡™û…4€@°Í) ’Ho®+Û˜‡3‰3sq_y"*(£‰ N½ø‘.µI<A]H ´ +2JÍÙ<oÏ»|›ã»Õmïu$Àïònßsé>nJ @V#†,‰  ¨[‡$ ò{±†ñSL¯ÂqWÓf"¡›º2S©´™Öi!b1DÃ¤øoØüöËşøëN¨VŸ¡|;]·æ‹6ÔÌ®=ú¨&?’€,'5ØÈåX[6/AğV€­ıŸ·%|˜_˜gñ‰aĞ”[¬7O®SLŠ[¤o€ @´†J à˜ ›:ı·¨}"Û‘uZ@Ø! Ü+•²löUëÕ+€I ƒä&§o.ıØ¾"	l_ìa,öË={ö‘H2Í\­Ñ”@pvyÑ÷	­õb±\/—ãõxüMCØı:	D`“G ØüAô'iÿá<Œ?|XÖËe'í8fQØYLöÿ¶*¾oğ°"0ö ¹±$²¾äØ]‘J•fDéÊôÕxÎr1Dê‹ˆÇSı!Üú–ÿ…_tãÿù55 02’~üşÙ/²^ïe!0˜Xp_îtŠ”D»_‹•Î/ Ñ“Ü“'¼ÀK‘ß¤(z ó‚u>¦tİ¾îlŒuø_/ Gáx9oXÑjÒµĞmŒ"-(.ŠKõn§øÃÀQdüc³ç¿(™‚Ø|:OiX¯ìşü!!0È‹PÜŒ`oŸ¸3ã:)²•î×€ÿ[–‚ğ10›i³é41£cI É0Xé@5›¬Ùë±^@Çø)y0z7é?Íõã/õ'HêÆ Ø82Nôßöû™é>ºZğåæÏº¾ÀRx’Í‹±N&|›O4YØD‡,„´<^LÓdnd?J0M›Š†óÊÕ:-’Ø@ÔNÙæÙÎg|à(·½yâ# ¿—Úß¿t_ıéŒ‰ü_8¦²2±Œ@´
œUìşK íŠ$™Ÿ­™š–4“Iìş{@2mÎ ş{ 2W…öÍŞßÄıO¸Ì¿ô ÈÓêC]“$p´õÎ?_qiakôD Ö¸&‚¬ğ£ŞG“ã-¦NŒ‹İŞ¤ßÂÿy[@Î#ï*D1ÇhÅt‹MW×yÄîMŸŠ¼şŠW "5d€$ ‰IBÓ&¤·iŒ~]TÌÕ_¾Ó öHÚ&¾ièçóù‡­ƒí“$ 6@°.	 Ø:éûÈh ¤Â}È“'OæóÒœ5Yà	 ÙÿÌŒú^Ïfsõ\®Ğ(8è'Øß¬7›’€ï_~âş }"ı?™ğ(ûèNÓé{=YôMú²ÿU¢‘òH€äêÚ°NP;ÿ£‚å¼_¾ÿ…
cqEı‹áÄó¦Lõ‹¤»á[şoeı×üLÙ{ò¹%»^X° ‘à9É‚!ü¬ œ_™‹÷ã=+“IÙ4’«^‚Uƒüû·(:r«ñ3¬È’ hi	f½z5¥Eã~!iAEUè,-¨)jÍV«5
rÀ*Ë?ÃèAv[m1O q`<NŒG#cdYêª± 0œí0°ÇÇìxsÁ¸Ûy¿Wãÿ<‡­Êè÷²Ruòı+¶ÜúZ% &“Äd<ÖÇ¶¶üÛïÇúp$$ÜÀ‘ è{_¸Å˜E¦QĞ#˜8CRÿj´Œ="¤3€İ èßä» ¼\:•º—y_% 6%¯«$€±iîÀïoòœSÕ±—ÇÈAVcGc±9ı­IàÃßsx“ÁÊÅå%[M`øÿdjßõV}VÏ;“kÒÂöÈ€ìÅyuËmµ$	€( ~¤)ñ¸«@ÆÌ$hÌüwĞT íaî/¦ö”Ç¿å2‹t—]Mz€XèRdá²59İÕÅB§€ÿwóÇ2õÄYx}¦”L•‘QhÊ™?¼m8ø–æÄ–şÏÛ
®„¼Ş|Š¢Íù´ã— Â(Ñnš Àñ¤å} å2+ƒ@\|6keS4¸uİÖ‰Ñ‚ ˆDæ8†ÆÆ÷xßğUò«’ŞğŞ‰âèşù›…ùÜ6Òï‘¶‘p Á|·ßówöI şAzƒ€½„í3ŒŠ±â:¹ÿsêŒ7µL=“™Ô'“Aú^ïõ:NG’  BàŒ½š]è7ì=«ä?®ƒ5´,nû-²ı©¥íœı÷m€,I€;ûPoÄv}Ù‚G÷VÕİ9öaÙà9ƒĞÿ^f¥ZŒó–Sê]lYUÕÒç.Ö4€ÿu&àÖ	€¸çÖ#IN-€v» „¤3,€…ù ó‹×ñ^|ŸE^Š¼øsäÑ€ÁGÛAÑ*MŠv.ÍÎ;dH {OİªûÜµ]Çµ"fd õµ¾ŞÑÓ™V&é4œØh0:öÂ992iã9{ÿÙû³÷wÅ9‘µ%Ñ!Û=3ZÇãäØqRifÍÁ ?ÈfËYÃĞÄ¸À¢ÃäË£’.‡V¯Ÿ¸Ÿãƒa<`‰Lm/Åööb¼´QEÑ?¿NÂQ^Â‘ˆ‘I"" ´5æ†½^¡—Nçyş¤ÿ2U)í8¸ğXu¤ş!Ğ?Œ?vDŸv	¬?ˆéüÈÏ¤tZwàÜR«ËL³ójØÚRAê±‰j“ÆMuîÑ‚Òå•…3;ù¹®Y×sx“M—ìò{`jÁÀCjÇoşı‚ñ(S	æÏëV¸"o Ñ  E¬Lš#¦ãì5d,5LéaZ£6IGNšŞ¶ ø3LìÉÇÿˆ½EŠÀÛ¦¨ğ*	`–©¦°ì2Àñv*ôßÿkIMwÃ¤ˆø'ƒ×íÿ¼õÚrzq
Ù›r·¹>ìí±=€•(•F¥b±SÌf{Ù4jÃ° Óøx:M§8‹ÄâKŸ.nÉ(8éı”¹K$¤]‚­‚¿¢ú<ÒîÁÎÁöÉD`× WÚ=Õ÷A1UoT
|ÿuºuêƒ:S×u»Nı¯SÿëäóÕ‡Ã~ì~Ö¿Æjş>|Dü$(ü•k€ë‰úÉ”ğû‚VÿFøø§ŸzÀ™äV¥›>‡y¼C¨§*¶L¶k¢ äâV	à°u9^—ğnÿ‚ÇÌµ9›gh}›¬3·N 0¶,ÛÉ=VD¢ÙšéôJ§yäI|'Æ§@i¢PH cƒ6¿Ÿ_×:!‡¬»Ô‰g…ƒÒX{_Í¶ÿ&‹ÒA¿Ûíuu½C ÈŒÁ"&äÍö&“£fÒünÿ+º,5oJü J ĞÂ*xJêÅ:gÓ"8|˜{Ø§ñJS‰Äa"‰sğ/ÓäqH7 ±K‘÷}üKù)cÇì'ÍŞâ˜«ÌV	 rÜbn,†0Îä„ìÜ(•Êš™lq/bçåãñ½¸ÿ¢H$sM x@Õ»Ô½³!|“şKãR)1YÕ=Z  _ÏN¿•-ÉBÙB±•©…<g§OŠSÛöb^›o¥!’@`äÒx÷
-È 6.À¿«€ï¡øi–iÙÔXËl±´™^ |?°é1R~ÿe;qÙô .ËÚO¿G÷œ°¸]eZÊ&»÷TO>}JŞÛG1vxü³Màÿl,¼´ÿsm»Õ bD©•J¬„]ÿ%	`îW*J±Ø*æ
Ü 3t³ë$gŸL@ ÌÈ«Y Ÿª®›8=±¯î ›Ä× ø*#ú§Ø;• Ÿ®‰VU¯´{b‡|Ì‚şÏP]ÓpÒrşÑ@ ødûëtê2`Øn<íNÚµÿğ3ÓL†§¸4ıMøø§HçÚƒsÌÿ'¬º
	öKÇ/ß=Á7QAÌØëL­9éÑ¥™àò|Ñ[ş‰&û}üö‹¥…Á	ÌÄ8E È€…©"üÜkïvİ—¨@iâ‰|?O«Ä6qT[¦Z ¹gOW\šV‹ÂF3ÔÅgäKMÃ¡@ñ÷‡¥ıR¯wĞK¥¤4mŸ_÷é42•EÓP,-x .MZø–•ËqRğD’VÔW×‹ Q_­L&3(
İÊ¨’|0‰h‘éôÁTæ…£. M¯– xwæ´çqŸÇ¿Ï.€²œ
İ{ÕÏ?”‰WL‰ ÀQ`óx@ÚN§³f6[ì‹•Ô¨§6–ãÅ!‘ "(÷N.Ñ£ê_Bë>¢}UÿÈmO—E^¤°ú¿¨¬iÃøğE?/Z`Öüæíı¯ß”f#,‰¡´çıø²0£æŠ[€}Y´À¥n‰¹¹ÍÍ9˜âè„ğ_yı¨3¿ÂŞ2Eà¢éŠ\Ç¿,=Z#ónq£PÌ‹×?Ìæ#IÚ|÷*ø?{Nlõ*p­?À""ˆ;é¼İÒ0äû/I€ÑşáaãpoïxoViÌ^Ú¯{¹^o˜í¤mãã1
 ‡“¸*ˆĞu¯>Ô|W ix›Ğü'{åLGİ ‘Àö,ßgâ“…!zÿëÎ½2 ÖˆÅfu²ıu2àÔ0mĞíö¾ÂÜW~X„»jƒı¦àš¹p{ø—/=`lma’œ7?å¹³]¬‡áV}Ëğ?å¤]ƒ×oép¿÷QûÎK~ÿ'­%=ÊªQú;±u& À\6ŸÌ<Ùh{If>™ó\ÊO«D¾ìmç;¼•ñûLj_)œ&ä¹·Eê^µ¤qºM: Æ¹qƒCv˜y¤=J$ô„ë¦İÉ$=±m—ïˆËjé«¥Q[rœ*	‘2Ã!»O$¨ “Éår8Ï€M¨=œ”2jôûY.ÕAA¸ .÷uüûå3¨ı¥Å#…ğºJ $¢4ª“ºN¦Ó(ˆçdg˜Ï2Ü‰´3&‡’ Â8,à€ÙÙä H²Àÿşèl™ÿ®æÁ³;&ëúˆ[8ÊA& VêYDg3Ğ³˜¿D[€vntèWÛ/ßğü×AÜ¸«uÔzJíºé6 oŞ,{M<A©å^ó>]üÏºŠk´Mz€0r“ºÈúòÄ0À ¼«\¯äø¿xÁ¼1û+˜šï^5¦Ş-w%T¶×?’fkŠe`üí4ø?Ïu‘WÃ»
Ø8˜ñB$”‹ËpklŠı@Ş©Ô)ííµöf‡ÙñŞñq£ÜhtRRaä9îr~ğ€ıSàw×mRHtªöK%Á·õ{„œ±mJŸŞ¶DêäÇ 5Äm´NËa ZCÜÎİ³Çcdƒ¨äÖm½3||K Şùxk›i=şwVæ”5ç­èyŒÃ¿™Gü|0[1[Éü£¼Á'ªVÉÎâoD‚âiëod³#µ^<š7ÔĞ¿šú`}$ /‚³á‘V‰ÂÊ¢ëÖÇãIÃ0ÜJ¦2åy®4 ‘Å(–fY®uqËz€ğ8×âA©TJ’Î÷IFûùıLfHıËòş!ÁTVBAT@ Á{8ş·R¿[¤r÷ĞˆFîA.gU-kVÍ´*ÍÏ4Œ¼™É÷ûyçÉÅ8G“pPÀEõ¿éı WüZEvOÿŠ‹¼U¤
,ƒò»å–¢iS~¢…w _Ûdæ¢ä¡ºÛ8²5zàß¶}Ãšç>š¾Ú=½I'u£ƒ2İ‚ Ø ÏÛVá»Ù² âmíÎJàN]íxÉQpğ_]¿ .I€«†,ÿÀm¸¨Ï=òVÖÃñŸ
 ÇàÎ‚ÿ­º
raƒÎüĞÍÉdª­®7yLš<…‘u²…B¿,v“¯*íWÃFã(~t„“0P'`€ Àn0OX€¹Uğÿ÷ØÕdß ö•@Áz°É—ÙÆïYÚI—1æ¾ÿäË6¯“Ï¦²@åY¤=N~B Ô<@ªOQˆÔÀ\ÃÚ7HPĞM^ˆã[ÿß¶C£^en=ûö;æsé›Àğ/çÅ›76GÙr“w[>ôĞØ H­2Ôïİ¦O¤±{.Z¢¾ÚûC€L…¡C=%ÄpuZ ±ÿ=í²Uîg­l:='0MÉ#fĞÖçF»·G|—ß×òH onD°y„¾Òã(iŒcºÒ¨8:5·æ(“LÎ©Ñ¤ê• e)ßKí—l "^ˆÑ4€?øQ8G#àcø£Ãaùı­rŠ…ÀR’ü‘ã 5!Â«¼ûÃ&É©Å.ÑdÕxõ˜À ¥?¬×ÁV”mK°‚&kx¢‹¶}3c6q ÿ¼vYá]^ƒŒØÙ…ı_°ÏV7¼Ìídër]\—Àb5	ãìo%®.AÂ_k_Mÿû=[“ °İmI¨d·´ïMc™WAmâ›;ş·qIàájxsi„ÆçÙ­œ“}“ëôcxÕ/Ói;ÉX™an8ìúın¼Ûø?bGG-òõƒT˜qd<^¤ øÀm'aĞı„û«!ÿh¼.@ÀüTÙ²>Êºã›‘Ù‰À(ˆSP1é‰“pœQ¹£ÑmŒíí ^hö„‰j³ñËÿİnú?x•|„®Wƒ¶NNbLØıóH õ:%¹ÏåìÙ3µêê¬;69€¬É²)¬eÓE7ˆåÛ`Èw¸éùgC¿¯^»EÇ°{r	Ğ‡À0ÇŒã883L×'´HŒ“Hˆ+#ãò&ûI®ÿë —ƒ•÷éÃ‡y?dêgvŸ+x~MK®$ÁU½áø?Gı¼èõéa
‹n±S‚E†odFb¬ÏÈİ‹ññıã6À©\¬exÄã¸Vdã¸Ù î†’òwÉ‰’çHË£.Õ#dåxéÉ$@e4ZG£Yr6ZvA÷Šã¼›×E Dn ğ¯! Öå"n(Ry›²Ì_† ˆ¾½]”é’ øFFÿ/Tw
Í½x‘"Ãşs§¿TÈ¸ÎDø¿Ùç|É	á „Û ¼*ğ¿Ò™Œ— ˆùˆæ’ãséŠ8z«…âzÊ%İäú RF4º>¦_4ÒÆh`§mv¡ÿ8ã{óGb"¤û… ô¹³cê;Ëömëûì² Ç\§¥ŸÚ¨Aãï§ÈÈS¼“Q`Ûrä0V€aÃ|¥RÉ•J¥\>ŸÇ‘€8J’£Ó±tË‚/$‹ª®#nÏôTs»)]Íç¢î&í}Nj«›j]Œ%<{óF^¬È‹£^'abu¶¿ïßñûB’
•M‘˜"¿È{Q%Ê#hæâ¸ø€æ€^rÕ<sƒÔÁ|‡~1®èq|† SjÚLã‰á
Íôvç _s”Àyı…JÑGD  ßòŒ_4$A{qT·äÑùÿËwiääb¦†9‰ñ>“Wğ
ÆûÕ‰ªŠåå¤â—ª:•¡}ë¾C}İ?d~«lwbıSûN½Ï³|´ğòU2ÀæhY4ÕZT“€HÔ±øqÎ ŠE`%•ö‚„³"H˜|€›\‘±_!˜×·|ÏyãŸšºû¡°¼h÷à'ÎóşWaOÛÆÁ7,¶odÔOtÕ7`o,åÿõE€Â»-î‰3ä‘[.kH2 õoé''†$îø÷FV,i‰Èó(AH3j&M-+Ú8t.ººFÜäú ºä3-ŸÅ§	º-£ğ{°ûüŸ=ÒvAVæ¿ç´ù}ißÖúKDxQÁçPåßùFqÚ	@~…U*Xô±àøi c\â5X£1FÙ‚h¡P øç$@¹\ÎÑcˆˆ€~¶ßï¥{½¾Öïcì ¡†„Íì@E=¾òÚ¾•w¸»Á¼ˆæQ8æºışÓq’Ş¦Ö6Ë_–€ÿºü¿/$[ €˜÷¤the^KÜ“õ,êRäûäg&hps@¯Ã&ºÊê(+Ş®V“¾î³on8J€½Çßx_¯Ğ„ãİ;ºàÏ=åù¨ñé4_êRêa}ë¾CÍTsÁö©ù­j.`PúÛˆqÙdeV.ÃABúœ%•0yè“iÂñ‘ÎZú/-±d–•²L3mš¥tÉ$ûÂÎ%€?À9x¼KõzıÒ†H57:7³Ë¯]püS“;êap€g~³°2‚ì9ş§t;Ø
Üoz-}Í¶1²ˆ[Ã€şŠµK&‹ ’<Î•Ç-ŠÊ©D ~ Ó›–71v2*²Å†ÿLàˆ7 ˜?z4Ÿh™Á`˜ÕuB®7gæN‡ºøû¶MÔÖEòƒƒjÿ¤½òû<Òş­å0G%À…'|ÿ­¿kYrüa}ë³~?Çû\6cDĞ<6ŸGõh4nÄã´ëöÈ.Ì±åOãà?¿··—ó¢ô‚®ç;¹NQ#HƒÃw£ÉöqÁÉNÕÍ`w^$øVA9šÅğ¿f >Ñº‘uşş^`j Äeó9¾„µğ]-_5ll”Èü5f’˜LßäĞk3~ w“ä]O¬¬(.5#T(KßªÛÂ×û£ß"Jà¼şÊ: ^?™×OŞì˜=ómƒŞvÅã³ä¾9ö–ú[àÓh£‹Í@¹x†¨àweœgtEÿARRGĞ×(1e“Ù,t}B·Ğ1ÂûğœÿH$UÿIEøwÅWóÿĞ‚”€T>2BØ­OR›É(óçI<^b¥a=xø¸/‰ >¼‡;ÒÁ’Æ/Hó]€~a‘ÅŒ™Ãaf8(f‹}8xX’ğİ¼4.&‚l·Ûlº…3‡9#Òâ<KÆ0†Ì]/pÉñ/w@ÔpEéüÀyé°Ng“£‚E‚œfìšáv”aY«¶õî¾ÿ¹›÷<ÏEwgª˜i²@? ¯Jà˜98é…üDÀòdQ`ìú£ H¸o`êà¨à¼aôr¯^a§TîÊ5â&×ÇÕĞ¼˜8·g¶Œ|‘äù®».`õ²´w X¬^=ÕçQí_«…šW«‚×ä{ÕM¥'lÁ¸“À@`ëİaôğÁ`À¿>ŸGôH$®Çã¸ét4Š¤Y?Ac¹Oãº[.—;4Æ[•b±^®×ÅF£e´ZHÁº)‰€î6ë^ÜİRN*è—€î€j÷0&$!„÷™²öğŸhÓÆÈKöò¥ºÖI2à¶ú¯­{Û\ÌÈÉ¼8À8æ«G2õœ¼çö‚×UgØ‹¦\„:Hc§s`ËÔJê¥ÒÊ|hR‹ Âzùo6Ï0£6L±Òªˆğæ« oØMRñú¼ê Îù1€ÜN¢¯è'vÊ`ø‘ã‡~¢ÈGÀñ±ÚÏÛ*x´í„¸Oã_êCŞN&Ñ	ô5%bĞŸK-â‘¡Æ1œ9¬“Ğ&N9 àÇõÁ5@ÿåµ“ÿ¾±6VÿÎmV½VEêdÁ'¨5¢QUïÀ‚Ğ3uİ†#ä8"—¯¯Ó¿Áç€mCÿ·•ßº<cù=›í—Èğ  díI,¼òrÃì1`Ì`Ü`è$	€û ğ¼txàX¡©d@úo*ìPÀ-íõr½,­i)Â&`£¡oúõ]ÖvÁóX !Ô5Q\ÖHP3#ÖaFí„0îìÊ ÿ[øÙşİè‹êüÀyNñ^YÔQ‚~Ix!³ °;,KX(×¸X˜òVıÜµòdÕş‘}Ğèa;Å FAwƒ)Ax?Bıôq¦¼$p‹Ç˜üB ôT"`§üŸSş@Y<B½yjÆ;æüìú8‚İ@jĞıùEíB»İÍ‹5Bİ!ÅqÓöOÚ$Ø©Ñ(1Nš8Öc¿ìõüÈ¦‘étSŠæ~ï©sÅöyşJNÏåü~ì_	@—dîÙ}Øx™÷îßs9øşKàŸï¢ß@€OßÛsu²{t_Ó5-©ÓZGa&ƒ øqê÷K²}èTR©öŞ›7­J«U/ÕëH@ñHIÍöCöÅ9–X€õËC…gÔ~h'áœ
úÑ$ù˜=~Œ¹Íy(Ücø@/˜/r3aŞ 
a3ñ~ø@t]÷ı#ª?ä'=C Œ=>GN~ÿ€#>àğJ ¿H‚×òJ!H+ÕjYÆ2ÔA†;ì,øÿ­L„Æ,äàà”!@y şfÓuá¡oóôG Êü?µ(Pàúû©şşü/	€•c aè©¯&õsˆ<¿Iz‚Z5×Q>
ªŠïÛø‡ó#Q-s¡“Mè9ĞC {è–ú\Å; kôH †³à	®¼v#r§,K·Ô±.®‚²âgÍ”i3Ã!@½ş´L›rçccìí£ßĞ=Æ@ŞW¨j·¡5Ü+h9€dº÷löàĞf³ı¶é¢x£GVø	 ìŠôÉÂH0n0t*	 Ã‡Gİù$@Ğ¢¿°ó'@¿°Ì@#Ù¬NC¾@N­™J–ì
9Wän¿º¶Cµ› ´%¤f1ãUœ@û„ZãÒ¹ühWTAC}>î=gÏÉ]84xzƒîñX†±‚ @'ÑA…,ˆ“?Ùï°lŒni¾dûçÿÛÛ)<—‰­®‚ÿª÷ŒJ @Ó¢Š<K#v;şØı—$ ^?>fÇ-BmB’DÀÎø?ï÷×QF‹I ›°ˆ¦¦µqH~P 'l»U"`”]îÊuâ¦í£ZÿÃ¶S6|³4½\Öı}±ãÇ×|Zõ1GøšèN§gEì’¬ì~ÆhHYÖ,=›ù‰oIxÃÆ!‘}ğ}¼(ø"nU\,RÁ/m