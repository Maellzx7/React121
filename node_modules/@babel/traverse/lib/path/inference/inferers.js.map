{"version":3,"names":["_t","require","_infererReference","_util","BOOLEAN_BINARY_OPERATORS","BOOLEAN_UNARY_OPERATORS","NUMBER_BINARY_OPERATORS","NUMBER_UNARY_OPERATORS","STRING_UNARY_OPERATORS","anyTypeAnnotation","arrayTypeAnnotation","booleanTypeAnnotation","buildMatchMemberExpression","genericTypeAnnotation","identifier","nullLiteralTypeAnnotation","numberTypeAnnotation","stringTypeAnnotation","tupleTypeAnnotation","unionTypeAnnotation","voidTypeAnnotation","isIdentifier","VariableDeclarator","get","getTypeAnnotation","TypeCastExpression","node","typeAnnotation","validParent","TSAsExpression","TSNonNullExpression","NewExpression","callee","type","TemplateLiteral","UnaryExpression","operator","includes","BinaryExpression","right","left","isBaseType","LogicalExpression","argumentTypes","createUnionType","ConditionalExpression","SequenceExpression","pop","ParenthesizedExpression","AssignmentExpression","UpdateExpression","StringLiteral","NumericLiteral","BooleanLiteral","NullLiteral","RegExpLiteral","ObjectExpression","ArrayExpression","RestElement","Func","isArrayFrom","isObjectKeys","isObjectValues","isObjectEntries","CallExpression","name","resolveCall","TaggedTemplateExpression","resolve","isFunction","async","generator","returnType"],"sources":["../../../src/path/inference/inferers.ts"],"sourcesContent":["import {\n  BOOLEAN_BINARY_OPERATORS,\n  BOOLEAN_UNARY_OPERATORS,\n  NUMBER_BINARY_OPERATORS,\n  NUMBER_UNARY_OPERATORS,\n  STRING_UNARY_OPERATORS,\n  anyTypeAnnotation,\n  arrayTypeAnnotation,\n  booleanTypeAnnotation,\n  buildMatchMemberExpression,\n  genericTypeAnnotation,\n  identifier,\n  nullLiteralTypeAnnotation,\n  numberTypeAnnotation,\n  stringTypeAnnotation,\n  tupleTypeAnnotation,\n  unionTypeAnnotation,\n  voidTypeAnnotation,\n  isIdentifier,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\n\nexport { default as Identifier } from \"./inferer-reference.ts\";\n\nimport { createUnionType } from \"./util.ts\";\nimport type NodePath from \"../index.ts\";\n\nexport function VariableDeclarator(this: NodePath<t.VariableDeclarator>) {\n  if (!this.get(\"id\").isIdentifier()) return;\n  return this.get(\"init\").getTypeAnnotation();\n}\n\nexport function TypeCastExpression(node: t.TypeCastExpression) {\n  return node.typeAnnotation;\n}\n\nTypeCastExpression.validParent = true;\n\nexport function TSAsExpression(node: t.TSAsExpression) {\n  return node.typeAnnotation;\n}\n\nTSAsExpression.validParent = true;\n\nexport function TSNonNullExpression(this: NodePath<t.TSNonNullExpression>) {\n  return this.get(\"expression\").getTypeAnnotation();\n}\n\nexport function NewExpression(\n  this: NodePath<t.NewExpression>,\n  node: t.NewExpression,\n) {\n  if (node.callee.type === \"Identifier\") {\n    // only resolve identifier callee\n    return genericTypeAnnotation(node.callee);\n  }\n}\n\nexport function TemplateLiteral() {\n  return stringTypeAnnotation();\n}\n\nexport function UnaryExpression(node: t.UnaryExpression) {\n  const operator = node.operator;\n\n  if (operator === \"void\") {\n    return voidTypeAnnotation();\n  } else if (NUMBER_UNARY_OPERATORS.includes(operator)) {\n    return numberTypeAnnotation();\n  } else if (STRING_UNARY_OPERATORS.includes(operator)) {\n    return stringTypeAnnotation();\n  } else if (BOOLEAN_UNARY_OPERATORS.includes(operator)) {\n    return booleanTypeAnnotation();\n  }\n}\n\nexport function BinaryExpression(\n  this: NodePath<t.BinaryExpression>,\n  node: t.BinaryExpression,\n) {\n  const operator = node.operator;\n\n  if (NUMBER_BINARY_OPERATORS.includes(operator)) {\n    return numberTypeAnnotation();\n  } else if (BOOLEAN_BINARY_OPERATORS.includes(operator)) {\n    return booleanTypeAnnotation();\n  } else if (operator === \"+\") {\n    const right = this.get(\"right\");\n    const left = this.get(\"left\");\n\n    if (left.isBaseType(\"number\") && right.isBaseType(\"number\")) {\n      // both numbers so this will be a number\n      return numberTypeAnnotation();\n    } else if (left.isBaseType(\"string\") || right.isBaseType(\"string\")) {\n      // one is a string so the result will be a string\n      return stringTypeAnnotation();\n    }\n\n    // unsure if left and right are strings or numbers so stay on the safe side\n    return unionTypeAnnotation([\n      stringTypeAnnotation(),\n      numberTypeAnnotation(),\n    ]);\n  }\n}\n\nexport function LogicalExpression(this: NodePath<t.LogicalExpression>) {\n  const argumentTypes = [\n    this.get(\"left\").getTypeAnnotation(),\n    this.get(\"right\").getTypeAnnotation(),\n  ];\n\n  return createUnionType(argumentTypes);\n}\n\nexport function ConditionalExpression(this: NodePath<t.ConditionalExpression>) {\n  const argumentTypes = [\n    this.get(\"consequent\").getTypeAnnotation(),\n    this.get(\"alternate\").getTypeAnnotation(),\n  ];\n\n  return createUnionType(argumentTypes);\n}\n\nexport function SequenceExpression(this: NodePath<t.SequenceExpression>) {\n  return this.get(\"expressions\").pop().getTypeAnnotation();\n}\n\nexport function ParenthesizedExpression(\n  this: NodePath<t.ParenthesizedExpression>,\n) {\n  return this.get(\"expression\").getTypeAnnotation();\n}\n\nexport function AssignmentExpression(this: NodePath<t.AssignmentExpression>) {\n  return this.get(\"right\").getTypeAnnotation();\n}\n\nexport function UpdateExpression(\n  this: NodePath<t.UpdateExpression>,\n  node: t.UpdateExpression,\n) {\n  const operator = node.operator;\n  if (operator === \"++\" || operator === \"--\") {\n    return numberTypeAnnotation();\n  }\n}\n\nexport function StringLiteral() {\n  return stringTypeAnnotation();\n}\n\nexport function NumericLiteral() {\n  return numberTypeAnnotation();\n}\n\nexport function BooleanLiteral() {\n  return booleanTypeAnnotation();\n}\n\nexport function NullLiteral() {\n  return nullLiteralTypeAnnotation();\n}\n\nexport function RegExpLiteral() {\n  return genericTypeAnnotation(identifier(\"RegExp\"));\n}\n\nexport function ObjectExpression() {\n  return genericTypeAnnotation(identifier(\"Object\"));\n}\n\nexport function ArrayExpression() {\n  return genericTypeAnnotation(identifier(\"Array\"));\n}\n\nexport function RestElement() {\n  return ArrayExpression();\n}\n\nRestElement.validParent = true;\n\nfunction Func() {\n  return genericTypeAnnotation(identifier(\"Function\"));\n}\n\nexport {\n  Func as FunctionExpression,\n  Func as ArrowFunctionExpression,\n  Func as FunctionDeclaration,\n  Func as ClassExpression,\n  Func as ClassDeclaration,\n};\n\nconst isArrayFrom = buildMatchMemberExpression(\"Array.from\");\nconst isObjectKeys = buildMatchMemberExpression(\"Object.keys\");\nconst isObjectValues = buildMatchMemberExpression(\"Object.values\");\nconst isObjectEntries = buildMatchMemberExpression(\"Object.entries\");\nexport function CallExpression(this: NodePath<t.CallExpression>) {\n  const { callee } = this.node;\n  if (isObjectKeys(callee)) {\n    return arrayTypeAnnotation(stringTypeAnnotation());\n  } else if (\n    isArrayFrom(callee) ||\n    isObjectValues(callee) ||\n    // Detect \"var foo = Array()\" calls so we can optimize for arrays vs iterables.\n    isIdentifier(callee, { name: \"Array\" })\n  ) {\n    return arrayTypeAnnotation(anyTypeAnnotation());\n  } else if (isObjectEntries(callee)) {\n    return arrayTypeAnnotation(\n      tupleTypeAnnotation([stringTypeAnnotation(), anyTypeAnnotation()]),\n    );\n  }\n\n  return resolveCall(this.get(\"callee\"));\n}\n\nexport function TaggedTemplateExpression(\n  this: NodePath<t.TaggedTemplateExpression>,\n) {\n  return resolveCall(this.get(\"tag\"));\n}\n\nfunction resolveCall(callee: NodePath) {\n  callee = callee.resolve();\n\n  if (callee.isFunction()) {\n    const { node } = callee;\n    if (node.async) {\n      if (node.generator) {\n        return genericTypeAnnotation(identifier(\"AsyncIterator\"));\n      } else {\n        return genericTypeAnnotation(identifier(\"Promise\"));\n      }\n    } else {\n      if (node.generator) {\n        return genericTypeAnnotation(identifier(\"Iterator\"));\n      } else if (callee.node.returnType) {\n        return callee.node.returnType;\n      } else {\n        // todo: get uˆ      ›    z…     *²    _ÖOöurÛ              L < F i l e C o A u t h - 2 0 2 5 - 0 1 - 2 9 . 1 7 4 8 . 3 1 6 4 . 2 . a o d l ˆ      ›    z…    ˆ*²    _ÖOöurÛ               J < F i l e C o A u t h - 2 0 2 5 - 0 1 - 2 9 . 1 7 4 8 . 3 1 6 4 . 2 . o d l   ˆ      ›    z…    *²    _ÖOöurÛ   €           J < F i l e C o A u t h - 2 0 2 5 - 0 1 - 2 9 . 1 7 4 8 . 3 1 6 4 . 2 . o d l   p          : 9    ˜*²    _ÖOöurÛ               4 < F I L E C O A U T H . E X E - 0 1 3 4 D 3 D 8 . p f p          : 9    *²    _ÖOöurÛ               4 < F I L E C O A U T H . E X E - 0 1 3 4 D 3 D 8 . p f p          : 9    x*²    _ÖOöurÛ  €            4 < F I L E C O A U T H . E X E - 0 1 3 4 D 3 D 8 . p f `      T‘     ©     è*²    Ào
&vrÛ               " < E v e n t S t o r e . d b - w a l   €      2‘    .‘    H*²    QË¡IvrÛ           $   @ < 5 7 C 8 E D B 9 5 D F 3 F 0 A D 4 E E 2 D C 2 B 8 C F D 4 1 5 7     €      2‘    .‘    È*²    QË¡IvrÛ  €        $   @ < 5 7 C 8 E D B 9 5 D F 3 F 0 A D 4 E E 2 D C 2 B 8 C F D 4 1 5 7     €      $•    .‘    H*²    ¸‡¦IvrÛ           $   @ < 7 7 E C 6 3 B D A 7 4 B D 0 D 0 E 0 4 2 6 D C 8 F 8 0 0 8 5 0 6     €      $•    .‘    È*²    ¸‡¦IvrÛ  €        $   @ < 7 7 E C 6 3 B D A 7 4 B D 0 D 0 E 0 4 2 6 D C 8 F 8 0 0 8 5 0 6     `      œ    ðÝ    H*²    HmvrÛ               " < _ P r o d I n f o . d b . l o c k   `      œ    ðÝ    ¨*²    HmvrÛ              " < _ P r o d I n f o . d b . l o c k   h          ðÝ    *²    €¬mvrÛ               & < _ P r o d I n f o . d b . U d A H t W       h          ðÝ    p*²    €¬mvrÛ              & < _ P r o d I n f o . d b . U d A H t W       h          ðÝ    Ø*²    €¬mvrÛ €            & < _ P r o d I n f o . d b . U d A H t W       X      †    ðÝ    @*²    €¬mvrÛ  €             < _ P r o d I n f o . d b     h          ðÝ    ˜*²    €¬mvrÛ               & < _ P r o d I n f o . d b . U d A H t W       X          ðÝ     *²    €¬mvrÛ                 < _ P r o d I n f o . d b     X          ðÝ    X*²    €¬mvrÛ   €             < _ P r o d I n f o . d b     `      œ    ðÝ    °*²    €¬mvrÛ €            " < _ P r o d I n f o . d b . l o c k   `      œ    ðÝ    *²    €¬mvrÛ  €            " < _ P r o d I n f o . d b . l o c k   `      †    ðÝ    p*²    €¬mvrÛ               " < _ P r o d I n f o . d b . l o c k   `      †    ðÝ    Ð*²    _mvrÛ              " < _ P r o d I n f o . d b . l o c k   h      œ    ðÝ    0*²    _mvrÛ               & < _ P r o d I n f o . d b . Q o N N A K       h      œ    ðÝ    ˜*²    _mvrÛ              & < _ P r o d I n f o . d b . Q o N N A K       h      œ    ðÝ     *²    _mvrÛ €            & < _ P r o d I n f o . d b . Q o N N A K       X          ðÝ    h*²    _mvrÛ  €             < _ P r o d I n f o . d b     h      œ    ðÝ    À*²    _mvrÛ               & < _ P r o d I n f o . d b . Q o N N A K       X      œ    ðÝ    (*²    _mvrÛ                 < _ P r o d I n f o . d b     X      œ    ðÝ    €*²    _mvrÛ   €             < _ P r o d I n f o . d b     `      †    ðÝ    Ø*²    _mvrÛ €            " < _ P r o d I n f o . d b . l o c k   `      †    ðÝ    8*²    _mvrÛ  €            " < _ P r o d I n f o . d b . l o c k   `      †    ðÝ    ˜*²    _mvrÛ               " < _ P r o d I n f o . d b . l o c k   `      †    ðÝ    ø*²    êm mvrÛ              " < _ P r o d I n f o . d b . l o c k   h          ðÝ    X*²    êm mvrÛ               & < _ P r o d I n f o . d b . G G H K X r       h          ðÝ    À*²    êm mvrÛ              & < _ P r o d I n f o . d b . G G H K X r       h          ðÝ    (*²    êm mvrÛ €            & < _ P r o d I n f o . d b . G G H K X r       X      œ    ðÝ    *²    êm mvrÛ  €             < _ P r o d I n f o . d b                             h          ðÝ      *²    êm mvrÛ               & < _ P r o d I n f o . d b . G G H K X r       X          ðÝ    h *²    êm mvrÛ                 < _ P r o d I n f o . d b     X          ðÝ    À *²    êm mvrÛ   €             < _ P r o d I n f o . d b     `      †    ðÝ    !*²    êm mvrÛ €            " < _ P r o d I n f o . d b . l o c k   `      †    ðÝ    x!*²    êm mvrÛ  €            " < _ P r o d I n f o . d b . l o c k   `      †    ðÝ    Ø!*²    êm mvrÛ               " < _ P r o d I n f o . d b . l o c k   `      †    ðÝ    8"*²    êm mvrÛ              " < _ P r o d I n f o . d b . l o c k   h      œ    ðÝ    ˜"*²    ÍÕ"mvrÛ               & < _ P r o d I n f o . d b . Z C l y M U       h      œ    ðÝ     #*²    ÍÕ"mvrÛ              & < _ P r o d I n f o . d b . Z C l y M U       h      œ    ðÝ    h#*²    ÍÕ"mvrÛ €            & < _ P r o d I n f o . d b . Z C l y M U       X          ðÝ    Ð#*²    ÍÕ"mvrÛ  €             < _ P r o d I n f o . d b     h      œ    ðÝ    ($*²    ÍÕ"mvrÛ               & < _ P r o d I n f o . d b . Z C l y M U       X      œ    ðÝ    $*²    ÍÕ"mvrÛ                 < _ P r o d I n f o . d b     X      œ    ðÝ    è$*²    ÍÕ"mvrÛ   €             < _ P r o d I n