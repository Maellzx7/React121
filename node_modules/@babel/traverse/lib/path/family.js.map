{"version":3,"names":["_index","require","_t","getAssignmentIdentifiers","_getAssignmentIdentifiers","getBindingIdentifiers","_getBindingIdentifiers","getOuterBindingIdentifiers","_getOuterBindingIdentifiers","numericLiteral","unaryExpression","NORMAL_COMPLETION","BREAK_COMPLETION","NormalCompletion","path","type","BreakCompletion","getOpposite","key","getSibling","addCompletionRecords","records","context","push","_getCompletionRecords","completionRecordForSwitch","cases","lastNormalCompletions","i","length","casePath","caseCompletions","normalCompletions","breakCompletions","c","normalCompletionToBreak","completions","forEach","replaceBreakStatementInBreakCompletion","reachable","isBreakStatement","label","replaceWith","remove","getStatementListCompletion","paths","canHaveBreak","newContext","Object","assign","inCaseClause","isBlockStatement","shouldPopulateBreak","statementCompletions","every","some","isDeclaration","pathCompletions","isVariableDeclaration","isIfStatement","get","isDoExpression","isFor","isWhile","isLabeledStatement","isProgram","isFunction","isTryStatement","isCatchClause","isSwitchStatement","isSwitchCase","getCompletionRecords","map","r","NodePath","parentPath","parent","container","listKey","setContext","getPrevSibling","getNextSibling","getAllNextSiblings","_key","sibling","siblings","node","getAllPrevSiblings","parts","split","_getKey","call","_getPattern","Array","isArray","_","part","duplicates","getBindingIdentifierPaths","outerOnly","search","ids","create","id","shift","keys","isIdentifier","_ids","name","isExportDeclaration","declaration","isFunctionDeclaration","isFunctionExpression","child","getOuterBindingIdentifierPaths"],"sources":["../../src/path/family.ts"],"sourcesContent":["// This file contains methods responsible for dealing with/retrieving children or siblings.\n\nimport type TraversalContext from \"../context.ts\";\nimport NodePath from \"./index.ts\";\nimport {\n  getAssignmentIdentifiers as _getAssignmentIdentifiers,\n  getBindingIdentifiers as _getBindingIdentifiers,\n  getOuterBindingIdentifiers as _getOuterBindingIdentifiers,\n  numericLiteral,\n  unaryExpression,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\n\nconst NORMAL_COMPLETION = 0;\nconst BREAK_COMPLETION = 1;\n\ntype Completion = {\n  path: NodePath;\n  type: 0 | 1;\n};\n\ntype CompletionContext = {\n  // whether the current context allows `break` statement. When it allows, we have\n  // to search all the statements for potential `break`\n  canHaveBreak: boolean;\n  // whether the statement is an immediate descendant of a switch case clause\n  inCaseClause: boolean;\n  // whether the `break` statement record should be populated to upper level\n  // when a `break` statement is an immediate descendant of a block statement, e.g.\n  // `{ break }`, it can influence the control flow in the upper levels.\n  shouldPopulateBreak: boolean;\n};\n\nfunction NormalCompletion(path: NodePath): Completion {\n  return { type: NORMAL_COMPLETION, path };\n}\n\nfunction BreakCompletion(path: NodePath): Completion {\n  return { type: BREAK_COMPLETION, path };\n}\n\nexport function getOpposite(this: NodePath): NodePath | null {\n  if (this.key === \"left\") {\n    return this.getSibling(\"right\");\n  } else if (this.key === \"right\") {\n    return this.getSibling(\"left\");\n  }\n  return null;\n}\n\nfunction addCompletionRecords(\n  path: NodePath | null | undefined,\n  records: Completion[],\n  context: CompletionContext,\n): Completion[] {\n  if (path) {\n    records.push(..._getCompletionRecords(path, context));\n  }\n  return records;\n}\n\nfunction completionRecordForSwitch(\n  cases: NodePath<t.SwitchCase>[],\n  records: Completion[],\n  context: CompletionContext,\n): Completion[] {\n  // https://tc39.es/ecma262/#sec-runtime-semantics-caseblockevaluation\n  let lastNormalCompletions: Completion[] = [];\n  for (let i = 0; i < cases.length; i++) {\n    const casePath = cases[i];\n    const caseCompletions = _getCompletionRecords(casePath, context);\n    const normalCompletions = [];\n    const breakCompletions = [];\n    for (const c of caseCompletions) {\n      if (c.type === NORMAL_COMPLETION) {\n        normalCompletions.push(c);\n      }\n      if (c.type === BREAK_COMPLETION) {\n        breakCompletions.push(c);\n      }\n    }\n    if (normalCompletions.length) {\n      lastNormalCompletions = normalCompletions;\n    }\n    records.push(...breakCompletions);\n  }\n  records.push(...lastNormalCompletions);\n  return records;\n}\n\nfunction normalCompletionToBreak(completions: Completion[]) {\n  completions.forEach(c => {\n    c.type = BREAK_COMPLETION;\n  });\n}\n\n/**\n * Determine how we should handle the break statement for break completions\n *\n * @param {Completion[]} completions\n * @param {boolean} reachable Whether the break statement is reachable after\n   we mark the normal completions _before_ the given break completions as the final\n   completions. For example,\n   `{ 0 }; break;` is transformed to `{ return 0 }; break;`, the `break` here is unreachable\n   and thus can be removed without consequences. We may in the future reserve them instead since\n   we do not consistently remove unreachable statements _after_ break\n   `{ var x = 0 }; break;` is transformed to `{ var x = 0 }; return void 0;`, the `break` is reachable\n   because we can not wrap variable declaration under a return statement\n */\nfunction replaceBreakStatementInBreakCompletion(\n  completions: Completion[],\n  reachable: boolean,\n) {\n  completions.forEach(c => {\n    if (c.path.isBreakStatement({ label: null })) {\n      if (reachable) {\n        c.path.replaceWith(unaryExpression(\"void\", numericLiteral(0)));\n      } else {\n        c.path.remove();\n      }\n    }\n  });\n}\n\nfunction getStatementListCompletion(\n  paths: NodePath[],\n  context: CompletionContext,\n): Completion[] {\n  const completions = [];\n  if (context.canHaveBreak) {\n    let lastNormalCompletions = [];\n    for (let i = 0; i < paths.length; i++) {\n      const path = paths[i];\n      const newContext = { ...context, inCaseClause: false };\n      if (\n        path.isBlockStatement() &&\n        (context.inCaseClause || // case test: { break }\n          context.shouldPopulateBreak) // case test: { { break } }\n      ) {\n        newContext.shouldPopulateBreak = true;\n      } else {\n        newContext.shouldPopulateBreak = false;\n      }\n      const statementCompletions = _getCompletionRecords(path, newContext);\n      if (\n        statementCompletions.length > 0 &&\n        // we can stop search `paths` when we have seen a `path` that is\n        // effectively a `break` statement. Examples are\n        // - `break`\n        // - `if (true) { 1; break } else { 2; break }`\n        // - `{ break }```\n        // In other words, the paths after this `path` are unreachable\n        statementCompletions.every(c => c.type === BREAK_COMPLETION)\n      ) {\n        if (\n          lastNormalCompletions.length > 0 &&\n          statementCompletions.every(c =>\n            c.path.isBreakStatement({ label: null }),\n          )\n        ) {\n          // when a break completion has a path as BreakStatement, it must be `{ break }`\n          // whose completion value we can not determine, otherwise it would have been\n          // replaced by `replaceBreakStatementInBreakCompletion`\n          // When we have seen normal completions from the last statement\n          // it is safe to stop populating break and mark normal completions as break\n          normalCompletionToBreak(lastNormalCompletions);\n          completions.push(...lastNormalCompletions);\n          // Declarations have empty completion record, however they can not be nested\n          // directly in return statement, i.e. `return (var a = 1)` is invalid.\n          if (lastNormalCompletions.some(c => c.path.isDeclaration())) {\n            completions.push(...statementCompletions);\n            replaceBreakStatementInBreakCompletion(\n              statementCompletions,\n              /* reachable */ true,\n            );\n          }\n          replaceBreakStatementInBreakCompletion(\n            statementCompletions,\n            /* reachable */ false,\n          );\n        } else {\n          completions.push(...statementCompletions);\n          if (!context.shouldPopulateBreak) {\n            replaceBreakStatementInBreakCompletion(\n              statementCompletions,\n              /* reachable */ true,\n            );\n          }\n        }\n        break;\n      }\n      if (i === paths.length - 1) {\n        completions.push(...statementCompletions);\n      } else {\n        lastNormalCompletions = [];\n        for (let i = 0; i < statementCompletions.length; i++) {\n          const c = statementCompletions[i];\n          if (c.type === BREAK_COMPLETION) {\n            completions.push(c);\n          }\n          if (c.type === NORMAL_COMPLETION) {\n            lastNormalCompletions.push(c);\n          }\n        }\n      }\n    }\n  } else if (paths.length) {\n    // When we are in a context where `break` must not exist, we can skip linear\n    // search on statement lists and assume that the last\n    // non-variable-declaration statement determines the completion.\n    for (let i = paths.length - 1; i >= 0; i--) {\n      const pathCompletions = _getCompletionRecords(paths[i], context);\n      if (\n        pathCompletions.length > 1 ||\n        (pathCompletions.length === 1 &&\n          !pathCompletions[0].path.isVariableDeclaration())\n      ) {\n        completions.push(...pathCompletions);\n        break;\n      }\n    }\n  }\n  return completions;\n}\n\nfunction _getCompletionRecords(\n  path: NodePath,\n  context: CompletionContext,\n): Completion[] {\n  let records: Completion[] = [];\n  if (path.isIfStatement()) {\n    records = addCompletionRecords(path.get(\"consequent\"), records, context);\n    records = addCompletionRecords(path.get(\"alternate\"), records, context);\n  } else if (\n    path.isDoExpression() ||\n    path.isFor() ||\n    path.isWhile() ||\n    path.isLabeledStatement()\n  ) {\n    return addCompletionRecords(path.get(\"body\"), records, context);\n  } else if (path.isProgram() || path.isBlockStatement()) {\n    return getStatementListCompletion(path.get(\"body\"), context);\n  } else if (path.isFunction()) {\n    return _getCompletionRecords(path.get(\"body\"), context);\n  } else if (path.isTryStatement()) {\n    records = addCompletionRecords(path.get(\"block\"), records, context);\n    records = addCompletionRecords(path.get(\"handler\"), records, context);\n  } else if (path.isCatchClause()) {\n    return addCompletionRecords(path.get(\"body\"), records, context);\n  } else if (path.isSwitchStatement()) {\n    return completionRecordForSwitch(path.get(\"cases\"), records, context);\n  } else if (path.isSwitchCase()) {\n    return getStatementListCompletion(path.get(\"consequent\"), {\n      canHaveBreak: true,\n      shouldPopulateBreak: false,\n      inCaseClause: true,\n    });\n  } else if (path.isBreakStatement()) {\n    records.push(BreakCompletion(path));\n  } else {\n    records.push(NormalCompletion(path));\n  }\n\n  return records;\n}\n\n/**\n * Retrieve the completion records of a given path.\n * Note: to ensure proper support on `break` statement, this method\n * will manipulate the AST around the break statement. Do not call the method\n * twice for the same path.\n *\n * @export\n * @param {NodePath} this\n * @returns {NodePath[]} Completion records\n */\nexport function getCompletionRecords(this: NodePath): NodePath[] {\n  const records = _getCompletionRecords(this, {\n    canHaveBreak: false,\n    shouldPopulateBreak: false,\n    inCaseClause: false,\n  });\n  return records.map(r => r.path);\n}\n\nexport function getSibling(this: NodePath, key: string | number): NodePath {\n  return NodePath.get({\n    parentPath: this.parentPath,\n    parent: this.parent,\n    container: this.container,\n    listKey: this.listKey,\n    key: key,\n  }).setContext(this.context);\n}\n\nexport function getPrevSibling(this: NodePath): NodePath {\n  // @ts-expect-error todo(flow->ts) this.key could be a string\n  return this.getSibling(this.key - 1);\n}\n\nexport function getNextSibling(this: NodePath): NodePath {\n  // @ts-expect-error todo(flow->ts) this.key could be a string\n  return this.getSibling(this.key + 1);\n}\n\nexport function getAllNextSiblings(this: NodePath): NodePath[] {\n  // @ts-expect-error todo(flow->ts) this.key could be a string\n  let _key: number = this.key;\n  let sibling = this.getSibling(++_key);\n  const siblings = [];\n  while (sibling.node) {\n    siblings.push(sibling);\n    sibling = this.getSibling(++_key);\n  }\n  return siblings;\n}\n\nexport function getAllPrevSiblings(this: NodePath): NodePath[] {\n  // @ts-expect-error todo(flow->ts) this.key could be a string\n  let _key: number = this.key;\n  let sibling = this.getSibling(--_key);\n  const siblings = [];\n  while (sibling.node) {\n    siblings.push(sibling);\n    sibling = this.getSibling(--_key);\n  }\n  return siblings;\n}\n\n// convert \"1\" to 1 (string index to number index)\ntype MaybeToIndex<T extends string> = T extends `${bigint}` ? number : T;\n\ntype Pattern<Obj extends string, Prop extends string> = `${Obj}.${Prop}`;\n\n// split \"body.body.1\" to [\"body\", \"body\", 1]\ntype Split<P extends string> =\n  P extends Pattern<infer O, infer U>\n    ? [MaybeToIndex<O>, ...Split<U>]\n    : [MaybeToIndex<P>];\n\n// traverse the Node with tuple path [\"body\", \"body\", 1]\n// Path should be created with Split\ntype Trav<\n  Node extends t.Node | t.Node[],\n  Path extends unknown[],\n> = Path extends [infer K, ...infer R]\n  ? K extends keyof Node\n    ? Node[K] extends t.Node | t.Node[]\n      ? R extends []\n        ? Node[K]\n        : Trav<Node[K], R>\n      : never\n    : never\n  : never;\n\ntype ToNodePath<T> =\n  T extends Array<t.Node | null | undefined>\n    ? Array<NodePath<T[number]>>\n    : T extends t.Node | null | undefined\n      ? NodePath<T>\n      : never;\n\nfunction get<T extends NodePath, K extends keyof T[\"node\"]>(\n  this: T,\n  key: K,\n  context?: boolean | TraversalContext,\n): T extends any\n  ? T[\"node\"][K] extends Array<t.Node | null | undefined>\n    ? Array<NodePath<T[\"node\"][K][number]>>\n    : T[\"node\"][K] extends t.Node | null | undefined\n      ? NodePath<T[\"node\"][K]>\n      : never\n  : never;\n\nfunction get<T extends NodePath, K extends string>(\n  this: T,\n  key: K,\n  context?: boolean | TraversalContext,\n): T extends any ? ToNodePath<Trav<T[\"node\"], Split<K>>> : never;\n\nfunction get(\n  this: NodePath,\n  key: string,\n  context?: true | TraversalContext,\n): NodePath | NodePath[];\n\nfunction get(\n  this: NodePath,\n  key: string,\n  context: true | TraversalContext = true,\n): NodePath | NodePath[] {\n  if (context === true) context = this.context;\n  const parts = key.split(\".\");\n  if (parts.length === 1) {\n    // \"foo\"\n    // @ts-expect-error key may not index T\n    return _getKey.call(this, key, context);\n  } else {\n    // \"foo.bar\"\n    return _getPattern.call(this, parts, context);\n  }\n}\n\nexport { get };\n\nexport function _getKey<T extends t.Node>(\n  this: NodePath<T>,\n  key: keyof T & string,\n  context?: TraversalContext,\n): NodePath | NodePath[] {\n  const node = this.node as T;\n  const container = node[key];\n\n  if (Array.isArray(container)) {\n    // requested a container so give them all the paths\n    return container.map((_, i) => {\n      return NodePath.get({\n        listKey: key,\n        parentPath: this,\n        parent: node,\n        container: container,\n        key: i,\n      }).setContext(context);\n    });\n  } else {\n    return NodePath.get({\n      parentPath: this,\n      parent: node,\n      container: node,\n      key: key,\n    }).setContext(context);\n  }\n}\n\nexport function _getPattern(\n  this: NodePath,\n  parts: string[],\n  context?: TraversalContext,\n): NodePath | NodePath[] {\n  let path: NodePath | NodePath[] = this;\n  for (const part of parts) {\n    if (part === \".\") {\n      // @ts-expect-error todo(flow-ts): Can path be an array here?\n      path = path.parentPath;\n    } else {\n      if (Array.isArray(path)) {\n        // @ts-expect-error part may not index path\n        path = path[part];\n      } else {\n        path = path.get(part, context);\n      }\n    }\n  }\n  return path;\n}\n\nexport function getAssignmentIdentifiers(this: NodePath) {\n  return _getAssignmentIdentifiers(this.node);\n}\n\nfunction getBindingIdentifiers(\n  duplicates: true,\n): Record<string, t.Identifier[]>;\nfunction getBindingIdentifiers(\n  duplicates?: false,\n): Record<string, t.Identifier>;\nfunction getBindingIdentifiers(\n  duplicates: boolean,\n): Record<string, t.Identifier[] | t.Identifier>;\n\nfunction getBindingIdentifiers(\n  this: NodePath,\n  duplicates?: boolean,\n): Record<string, t.Identifier[] | t.Identifier> {\n  return _getBindingIdentifiers(this.node, duplicates);\n}\n\nexport { getBindingIdentifiers };\n\nfunction getOuterBindingIdentifiers(\n  duplicates: true,\n): Record<string, t.Identifier[]>;\nfunction getOuterBindingIdentifiers(\n  duplicates?: false,\n): Record<string, t.Identifier>;\nfunction getOuterBindingIdentifiers(\n  duplicates: boolean,\n): Record<string, t.Identifier[] | t.Identifier>;\n\nfunction getOuterBindingIdentifiers(\n  this: NodePath,\n  duplicates?: boolean,\n): Record<string, t.Identifier[] | t.Identifier> {\n  return _getOuterBindingIdentifiers(this.node, duplicates);\n}\n\nexport { getOuterBindingIdentifiers };\n\nfunction getBindingIdentifierPaths(\n  duplicates: true,\n  outerOnly?: boolean,\n): Record<string, NodePath<t.Identifier>[]>;\nfunction getBindingIdentifierPaths(\n  duplicates: false,\n  outerOnly?: boolean,\n): Record<string, NodePath<t.Identifier>>;\nfunction getBindingIdentifierPaths(\n  duplicates?: boolean,\n  outerOnly?: boolean,\n): Record<string, NodePath<t.Identifier> | NodePath<t.Identifier>[]>;\n\n// original source - https://github.com/babel/babel/blob/main/packages/babel-types/src/retrievers/getBindingIdentifiers.js\n// path.getBindingIdentifiers returns nodes where the following re-implementation returns paths\nfunction getBindingIdentifierPaths(\n  this: NodePath,\n  duplicates: boolean = false,\n  outerOnly: boolean = false,\n): Record<string, NodePath<t.Identifier> | NodePath<t.Identifier>[]> {\n  const path = this;\n  const search = [path];\n  const ids = Object.create(null);\n\n  while (search.length) {\n    const id = search.shift();\n    if (!id) continue;\n    if (!id.node) continue;\n\n    const keys = _getBindingIdentifiers.keys[id.node.type];\n\n    if (id.isIdentifier()) {\n      if (duplicates) {\n        const _ids = (ids[id.node.name] = ids[id.node.name] || []);\n        _ids.push(id);\n      } else {\n        ids[id.node.name] = id;\n      }\n      continue;\n    }\n\n    if (id.isExportDeclaration()) {\n      const declaration = id.get(\"declaration\");\n      if (declaration.isDeclaration()) {\n        search.push(declaration);\n      }\n      continue;\n    }\n\n    if (outerOnly) {\n      if (id.isFunctionDeclaration()) {\n        search.push(id.get(\"id\"));\n        continue;\n      }\n      if (id.isFunctionExpression()) {\n        continue;\n      }\n    }\n\n    if (keys) {\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const child = id.get(key);\n        if (Array.isArray(child)) {\n          search.push(...child);\n        } else if (child.node) {\n          search.push(child);\n        }\n      }\n    }\n  }\n\n  return ids;\n}\n\nexport { getBindingIdentifierPaths };\n\nfunction getOuterBindingIdentifierPaths(\n  duplicates: true,\n): Record<string, NodePath<t.Identifier>[]>;\nfunction getOuterBindingIdentifierPaths(\n  duplicates?: false,\n): Record<string, NodePath<t.Identifier>>;\nfunction getOuterBindingIdentifierPaths(\n  duplicates?: boolean,\n): Record<string, NodePath<t.Identifier> | NodePath<t.Identifier>[]>;\n\nfunction getOuterBindingIdentifierPaths(\n  this: NodePath,\n  duplicates: boolean = false,\n) {\n  return this.getBindingIdentifierPaths(duplicates, true);\n}\n\nexport { getOuterBindingIdentifierPaths };\n"],"mappings":"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±Íˆ˜°Ğ_ ¦–D!Ëãóê©Á¢MÀ~Œ7Ò‹nnJ÷mo ñçMáU²jE£«y¾ÑÓ<ÚÅøÇU$µ:ÿ¸„öCpW£yÂ)ì#£ç1Ãt:ø5™ËøµiâbñÌÏ°Ÿ¨¯UŞNSÜ•¤$—Ú¶y‹Í.ï‰QÖÉ¹WİšN)¾)iÈåÆ{§0±{&vHà.Q+¾KJ²Ùz×N¨1ÚSB!'ãª#QOög›L«T‹È²åÖ¹•^8*	°“:†xgN¹7ĞRÛ¯t<µ 9®ÁNû¬	Q6R*ö¤ÄbY–AÈi™×Ó´N¹2]´¾4ò¾ë‘Û^¨â3ÆÎÀÖNÛmÄt0æôrE}Ø ÷òFÎ/ºYe‘¸ö}¬«d*;¬GòXG•ü»^æÊê="EÇó5mâähtc’™ ÷²øiMÄMÌ-Ä¤6x C"Àı³ĞI]›A¾Æ:õ’ı_7–˜¨„(ß¿k^Ã
û4"ÿÚĞw{îÏLV’ƒI€Ê¦t­ùJ§i¢­Òü_£Iağp(;ÃY[‡$7*ÑXiı¿VgÀAÿİ×ÛiÃ.stàš”o1åe¡xª<ç™?Š×X±²eõ |Ä(›|Ëp-­øg®;¢¯Y_k.NUQ@³_JRÜeÑ¼Yf7Z{£#åI.ÿÃô%çÁ˜™ï_¼¬¡6Gãğbã9ƒ ?Ëb	±8eÀ™l§ü—Oo#®À:É¹MØDíğq¦D ¶E=µì¨aNWi4+Œøê³dÓÑD¨ºât8¨~A"BWQÙÇÓZô™íM¾ê{ÓÉtZ¥NDM¾8‹ûİKM%P5L~×Ì‰‡0ëù"äRHåbàøõøÕ\åFâ8uk½	Ó¹b‡'J	­¦Wh;‹ºÇ&õ–÷eÓ¶£¸Ë¨rVŞ}ÿ®Å¬]ùÓ<oÉ¼`\H¢ÌÙ6K­xµQ3G‹³_S¨ÉTÓ±˜i$¤ÛÅŠ<Ş™x{jQfÈüz rÈ‰Øºç
½HZB;8Áû©
¹ßQzIU/UïRİç×š(6kıHe&Ä?nVş®v
³o€¶×¸•?;Ş~õûq=õÎ<Û-}ãĞ|×Ÿ<§ùY†¬²¨ Şs\£ƒŸ^siò>‹P~c`îÏüR`ÚFi÷T$ª:zÌİ¦óéæ¡Vyct}²ÆTa¡$€¨*ÇS›>¬Õ…5´ñ+5ö\æu\w™9×ìŞÑ&»‡óš5à1[	ZåÔU¡­}ÅòÈKKU;šÄ…Fµ:gNXÈUËX ônN#àˆ¯­q r°£=FPt	V%§:¥ŸÔ¨v-ƒë‰ÊÁ|-Ë{¨İ¥îl#µºGÓ8¶ l“ŞèJA•µY†g¿Y´ÉC/|ÁşL“Ob#‡õÁ¾v÷ÿlÄÑº¿ˆ-zåíôõŠ¥6”a	§ÉÏˆÙÇä–“êôŠš½téÌµ3`İmîÁóÂû})®§%N­çº£¤´/á?Ô»hĞòä”ŸëæjØØ‡ùd€VàÕ¥"Y¬AëğñÃn®j4í0§+)oÀØŒ'QÃÙBd1R|ä.MDŒznw8txÛºqšFMÅ@?Nx$y¦\‰fâWBï›§€•bùŸ£”¼ŸZèÒ´Êp@<½ş)Ë†ÓûXÙ~gy†´38r, wå£½“8;[î‚Mù¦€f}67iíÿq¤2keÈz&f%sÊY)?. ¼åûÂ#â}E^‹JÿKÕÂ£Õ¦e.ï1ÃT	Üşc›‚R¯õ•»[\‘üA^Äş	èghŞa"mÇnÃƒäˆiÑÙäŠ¬Ñ)ınŸué¾ ˜]Xn¯Ôô	¯E’a´Î§™8†ÿ$ÖI1JW©M.K¿›¿[ìy‚®›
µÎ]X««ˆŸxhXpìµ_’$yËÏ ¨	8^Çe^	[³rW¯\Q{m‘ß‹×yŠ°ÂÕ£€Ò¹¦Ô+†‘ÃEN|Ûh9óˆN½Î]Ï?#Ür×zWQ "ø‡¿³máäß£-s™X+™×¿ûü¹ƒSEaÊq \O‰ÙB‡²~Ösî°G×m[¶­íA÷n×²"|N{s:¬œÓÙÉ*~…j‹ ‰o†şÂ4‡ê!3€m;]S±BOäA@`xsû Üº½0lë¨ú¯ï±gâ~ıÍuùøå(áÑé€YÇÏd>ç}ü(y÷ÖÊ©Ñ è·2&Úåğ×š´6Ä8ƒ§&¿|êù¬Ü b•­À-EAĞ
ÌÓËïœ>V”ç€ S<»e¼ĞTN¡Jğ$UÁ¯g›b<Ñ¢-™7§ZŠ}Îc¡—·w!¤Â˜-f±ªAª6dé™èGcı'õÍj¬“u…$g¬Î“Êâ¼ÎÌò\q0ÄL¾­Ö“6³¯, Ğ%ÌCRÎLã­mÔÁˆÈEŞõk‚Â@¶¿Oe}¹Š‹fé3ÏNh=]ÅYÑø‹'­ŠŠ0®TnÅË)Ñ³uÆ¶ÎYK.H®6İµcª¢¾!seN("z¡5H’«5Æ…ÅpÓ9²l'4CSmî
.ß¦aqC¦úvwNip°øÂ˜PÌ=ÇWÊTÌY™XŒÒvßÓ&ÜñÀáŠâ”I7“¢•í2p`XìQlO(có_Ã›J©!åxé>Qdô`ªx	Ò÷Ê r:äy‘rü„¾Ó¾ÿOû#güé-§I¿e%³:’hçñ¿A•ƒmãÒÏéA\rë­æ®M#\%Vânäî­ì‹ãåµããÄwr/Ç92µ`îAwZH¤nÔºÉ:¤~‹‚‹Ó{ÜYÁÛ7(¤ÍÌ*kõX¿1ş”ÇÏ¥EiF™%¿eÃ ‡Jiœ6o/Dœ
äuÆ2oØÓË3ñ`—€Q¤ñ&íİçòG?b]Ö]YbñÕd×¾§›&÷¯ã¼†Í‹¨¦6fÈ»Roç,'[QªfÂSé}ØşkŠÆ*¥àï‡‡tï,¤şÒôNûñ—9ú¡:¿ê-¨ô8*Àâe¯^DÅÃ¢î  &Ôkg_©úÆ­9ëÍn–yaÎËlçç}sÑ³\¼ãRÚ702Ñœ‚‘ó |N“t{óÖ½O1ø¢¿ÙğĞÕâC®¢´À²ÂdR&V'KY¥™Ša¡I Ÿ¶cë€±w2€—ì1uıö#2øN.³—4!5î’ÊòC‹9éØŠƒ_üúPëº/`%ŸÚk’í•%NË„P Hç‹8Ï9İ~ÎŠsw}É:Àºß µ‰Í&Èg±±|q)4éÍÃÎ’ãiŒ ™§b˜›G	ø·ùÇV•^rõâæ‚­O½?Ê ^Ó4\8Æñè„ àBcË'^[¨6oÄ¾–r0&ù8ò§ud+¯»ƒô)àIM­²ß°¿ *RÄ_yÎuêE#ºc9*jß2á±ß‹‘JŠì|8Ù
‡A8Ôı»…åŠq¯…¶Ã!OL¯ÄA§º£d†×úİğ†=İ»Ë–[sÜ
sHzë6.ã¨Øašp°´Ñ†$ª²t~;ÀxS˜–r±ï#Í9h«”3† Å¸¥ş‰‰0«Ïà{~Œ£J¸œt9zŒÎëWÃÆ4Ã£İaF$CŞ?&/hİ2pÚ# )ÿïötK!j!"ù¿F@´Yr×xÒ¡ Ä¹â}TÏ¿5k´E8†ÎÇÚå$$<cXš!ÔÔtß»çÚŞ„uô¦ƒLfÏ›¦%)ø4æbÜ¹‡¯ÄKz¸š5­¸{Ø¨Ğšh¦¬‚cOquœíGÅ#¯—/îÖ[8|¤£u1‹ç3TâkĞ­ïp~M|Çú¤ËÑ–‹Š"ÂWşë,†AŒnF²`°¥Ì.hæŠ<øÖOøÍ6J6 ›xƒìaYjõ¡§—<Õ&g} ^áŸ¹…2„°:‡:Û[øFûg¹JC	RŒî¹Ûm§X³»ß*‘îôPö*-NÚzç'McJ.z›Š)º‰•‰.{7[õŸCu	ÄeÇ%³~ÒøD¨Ù¯÷0M™#¼‰7#PJoË,£WùH0@®B4z0ç
út¢5Ôuš©B&»ğî[«XXËuØŸW€87B:få÷yø Bã8R/ IüãÄ‰B=Ôı‘şoD¥ıPWjà0yÛqÀdG?Ø¬Åà3çDH:IdU¨éñ“Äw©à]\˜!EÚ¤}ë9bW£¶j'~Îˆ ÈÑ¡IEå^¸ŒŠŒ!-Õû‚-®E’£kyÏ•œûò~¨™À™L9]à•do3=rÄæñ£îƒÒmKm»£æ©æIÄÿìûCù6@Ë–ª»œV`å µİNWÂDÕ@šŠxtãp5IünÈ-4NLV5¯:JW?Ç|—”/ÄØ´kõ¯É@pœh]°‡È™âƒ_Ë§Ç¿•6^EQÜ!Dk4ú÷ÀYR,Oß.ƒ´–Gœ‹¥‰ÒØıà!Sò'ğrlZ…D‰p[˜5A3ç%]CÌÚ•ØhEWv…`G
g¶TëÚ´İuÆ-ê¨¶k>ÿÿh¾¾~æö¯±K/¥Ã¦íOïâE®R¯#”ïÂÕqv—"¿4f|võaÇ,å¡–T2Ó÷Wk$î+Ôş]Ì åÙr‘âúQ¸ùÌ¤Ÿf€ÌÚ'whä˜X|NğXDt¶XW°Ô;Ë ßÖ½{%»=¾ŒZà„)iìÇ<^Ï+™b{’	:ĞMËÎeª–ò\*‚oâx~ÙÑ„y¶¢‘?ŸV6HíÌañßéğSa,ü å˜¼|œY éiYOA€?í=.æDl=h(¬ôslJ¬o İÊÑÍ«¸6ï@Š?ÇwrŠëÚd3È–$*Cë³€¡/¿¼¨ôíòëÄ?n©|P¾åÕ®ı~³ë^a‘‰u²T/óªüÃ‰™‰Ñ<wN—Ş€¿8Kh½Â6TôPéG´#Ä?ÍúÖÓ?}½ ¿r_òl©wÎ\÷Ê›½eîïN¨jKŠŒ9:ô¬ƒĞî™]ÄŸìF¡j$i‰²£Öè°b/õi?(.À’0g:MJŠEæ,ëB’ñËÈ†ay§9àæëëJÊPÊØÍeÅ?n/Mşè’Ü‡;úV6ÿãAo‡Õ«1€iıwÃhnÙj÷%é¶Â¼›ïúÌ…Ğ”×efÎ	¶ SWÎ”(–¨3˜ßŒÜ¡;ØAÀ2«÷Nf{Jk(’ì8ÄÜ×‘Ö.Ä'R1nOäƒM)<Bµ*ä~[:ÖïtŸ`8äÄ©ÏâèÀƒĞÆ+Ş"Úøº% óRºpèä?Q¯ƒtdhÎùL1³ÉPÿÆk±®ˆÌ˜xµ÷{Ç à®5Âµ&Üú'ó}ÁUù"¦Äa0åg‰aÔE§÷${¯¬íŞ£EŠüŒ¼›cËxÙx¾£ÕFpR…îm‹ÑpøZºå‹DTçT«»±M]k¿)£µR	ÇÖŒ£dÛ‰®_ï²Y9›-ÕùĞ,xƒ§E˜â®>\f‰lS'ç‰ı|!-¬ñ§úË@ğ»i˜q´¼QÈë ˆBX'DÀ†eè]J«pº¯Ü7ú J}­ä«cèÅ&; Ö>`òú°¼ö¿Õ(jrÑw€y2©Ç£Kdö–ŠM^/¤¤~ŞQY>&Æ<»UœÍø¹wPvK=gWÛj³VL1Ó¶1UµöR¸Â³Ï{Tù:GéMÙã“|ú‚ô³´#ZYy5Z;@#MVP%å„¼S>»Ö«ø«8]¹Û¬Z}–r8Îyvş¯,––Š“(‹Ÿ¯­¢A~à'²İÄ•âÈé“sŞ1!Î„Øš½Ş9Õ<»=t‰š	l¦	ûcN©öÓ°”^„¹ßhŞ8$ÁŞ«Õğä”c³pÕâPÄ(ùìšªÒÄ®ÎMáŠÏÜŞâyAŒíœi}‰av‡‰ô*4 å[Ö·¯År!Åt™ØjÖ ‰\ŞÒÿÚûµy´\áÉs’¢ï™®HVµÒ´¶XÿGoÖ©Üƒ-±s,Ûx%ïŠã]Yûô}k2œ>RÌY]©QˆUÂ¿m£l“Õ?ğ*¨gÇˆqn;ÓmPØ
õ«›×bÃ±¯)ş(”W7'œ¢'á€¶U°…©u.9®áåismûGØTŒiÄS®Ô»¿Âúq}	3jšj9Åoæ…†'¡ş=º·®g¦&Õq+Páf~Í©ëbâu´éŒÖ²TFõHîM’=ˆ„Àí‹hQ¶HµêÃÇ[ª¹ÿ%˜$²Ø3‡ãv~ü/q+\Ê•ÍY%{ıÏ¥».*ŞdJµ÷IÇxXÏNØ|"üaxnaPc‡ğ½äŞõp&ª@v9(ÌÚgJ—Ş*L¬Ü&ùezœûL($Œœ=Lo÷ñí °¨­lYÍ„á§‘ó_}¡—Á	ëÊ!(ÚmÉğ<E
¡K‘	W—V…¤3©Y®åPó$» uÂ~˜)™×‘ˆ¯Püø=l¸š»¾W~±X_1¦•8¦laV¶1ÊÁy]·M]2ƒ«EÍ[WôV<Õ¾¼ÅÕKşãEPÉ®ÊóhEèi, ()Ë1sÅñº+Ä*… -"Ò®7b°Ï µb:¾ó5.%³Øü—b¹ÈRIK|0Â_/ƒÊØJRÀ`6.ãÌpù ‰â×UYº2IÓÉ¥-7'ÉşıdÄ…­ŒsRÜ,Q?Fºñ~ÕÆÿGrÈà\ÏÌšvtºğ1>›oV6U“ò{`Ïö80Si¨´›çÜ#ĞóÚè˜¹É½Q 	\¬	iV0œBÙÀ°tØ[¦µ|¥ÙÒŒezÉ¦U–¶Ã	SB¬ ›‘QÖåií¤ÑéH20)åÓj÷C¯9­Ø°V;\åğ ^GŠÌè‘ø/‹ˆj“¦^M{:ë4m&$(ñMïŞK	±Â@h¢ä’d;}!3P®›[ã	o!q–`ö“å0ë#ıO§+ŠO"X‹<P4™l!(”ˆU†NÂ“´Æ `xhZ%ÏI.$ÂŒş‚xÄİUæï€àPr1ÆñÚÅ÷‹²y}L™¢Zu@gß'F6§Ì VáÄ"ú„	°;ĞCÁKšú¤<±¡>Ş‹Zl~¤újEµ-nı•zXeµM¨6¶A¯²b«n7H–zøˆ‡JÄï©ÒşÕ·z^5òm¶%D€IËs€ßÒ7‰£³"ŒoøjxgéDUR-ªa„áÄòÆÂYû¾gè8}œs+VLÚµ$4¿+v)ğ<!gK›ÓXQQ<‚}’f1/yz	»Æ ¾x}}áå#ò)bÎß#>ë^×3Ãö]D«sk„|´VhšoKğnX´#ª#’…šVMöj]V ©
ÃèDÌ}­K¬g±¨á¸=%Ÿ6ªô¸õ>¤ŞİÇÄfxVÕòµÑµ=¿^3ÕİGšÈ+™om`éo¨Ò¥!’äï«9`¦<ËmAq&\2‰ 'œ”Í3°È¨Ã:š¢÷‰œä.C[ÓGÍéÌAGËÌÃ²±(}¹cĞÛXN}ùÚï°Í…oNYõÃxAl®Ù#VóE*Ä•oùœ)ì#Ä©Ai«ôïj<ºÛ ™âOš#>„Ä3¢°*ëÁªg—+L¸ô³oÚó>ÄDÕ ŸÅ—ÑÍâii.ø%-à¤ã`A­Êp±§öêYDşĞgŠÏAÆ¶âğ õyî£;6ùœ©A€Q}ÔµÚÉ:ÊF`À:ZeÃÙö½{i‚C?IvXoİFI²pÀêÙNc,Ä¡²#Íå¨Ä¼âØ¯qYÕ vÁ“†Ìë>¾CôrÌ‚ô²× TJQ%şİÙ…äh¤wG{vÈé>À/nÍÑ†û·­gÌ/".œ0~ëÖÑío»˜‡Qß]/Ê–ìÆ…’j0Ö?«€c
C¨á£mc¶Ç…ıo•ÛÏd>¶mçéuû'd¢íb·PLq§wå“q‹Wlœ$»&¿J¤VöPÛÍåm>Ÿ@¤üí¯tÙ.Ø
ÚµÄÆ0Ô¬\M”ßGe³ô¹è§ô<Õ® ³‘>!ÇÛèj7ø³•ïn_çKR/,<6ÁÙAB?hWø€ CEÉÛa•9µÎºk8®qxhµ´œ,‡ábCÄf mHå~4Z»üRÊ'ÿÿ3“2‚‹Ä„G:ÏQÜ‰‡;û3Œ–Gé
ì,«¼yÚ.É³¹Ë:wyZ*uŒ¸‘!³§)Zƒ·<Åq¶K´îJ“àYyû6jGŸ¨Ï#r‘wzŸ9õõFMõBô™{U(›Ñ)Fñ‡ˆ¢ÓóFä~hŞ\T BëïGNÃÇİ^64„Ë¨ä•¯ıÌÕŸOúÿéòÉ£ë°`6ÂÒQ(Ï]äŞÍÔŠCU£>+„R1B$Â(1ÅÙR(øi;'˜:–`8”5
5¼]Èôb3\"™ì+6¡	@ş>¦ì«h4«‚U½ã/ù…yû•úk¾Ş;Q&¼`C+n"÷vá0æ?ÂÑÕ*JÉÜPBNo×5p’šİ$nÇ	œŞÚ{F¸È™½Şõ)œr“a7Ö×¢r
ÄÂÙ|(Ôåš {’B2I3÷è$¨ç7¥@…a·h_a[q«*&¯Ô‹Ş çJĞ›¼iVœŒÍ¦¼î»|§›àÿôo0C+Ğˆ¿sVVÿqo6ÔÀ'Y¹¬ãÎ=
rİøËEõ´Äô ıÏj˜4î åÜï¬üR9]ËÁµ\¬ß˜˜“÷ƒß#(cšK$